"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.loadPlugins = void 0;
const fs_1 = require("fs");
const path_1 = require("path");
const common_1 = require("./common");
const inject_1 = require("./inject");
function getContainerDir() {
    const currentDir = __dirname.split(path_1.sep).join(path_1.posix.sep);
    if (!currentDir.includes(`/.pnpm/${common_1.cliName}@${common_1.cliVersion}/node_modules/${common_1.cliName}/`)) {
        return (0, path_1.resolve)(__dirname, '..', '..');
    }
    return undefined;
}
function getLocalPackageDir() {
    return __awaiter(this, void 0, void 0, function* () {
        const proposedDirs = [
            getContainerDir(),
            (0, path_1.resolve)(process.cwd(), 'node_modules'),
            (0, path_1.resolve)(process.cwd(), '..', 'node_modules'),
            (0, path_1.resolve)(process.cwd(), '..', '..', 'node_modules'),
            (0, path_1.resolve)(process.cwd(), '..', '..', '..', 'node_modules'),
        ];
        // Right now we always take the first one, but in the future this may be different
        // once we come up with more / better criteria to identify if its a good/valid
        // plugin root directory
        for (const dir of proposedDirs.filter(Boolean)) {
            (0, common_1.log)('generalDebug_0003', `Checking for potential plugin directory "${dir}" ...`);
            if (yield isDirectory(dir)) {
                return dir;
            }
        }
        return undefined;
    });
}
function isDirectory(dir) {
    return new Promise((resolve, reject) => {
        (0, fs_1.stat)(dir, (err, stats) => {
            if (err) {
                reject(err);
            }
            else {
                resolve(stats.isDirectory());
            }
        });
    });
}
function listDirectory(rootDir) {
    return new Promise((resolve) => {
        (0, fs_1.readdir)(rootDir, (_, files) => resolve(files || []));
    });
}
function isPluginDirectory(dir) {
    return __awaiter(this, void 0, void 0, function* () {
        try {
            return yield isDirectory(dir);
        }
        catch (err) {
            (0, common_1.log)('generalDebug_0003', `Could not load the plugin at "${dir}": ${err}`);
            return false;
        }
    });
}
function isPlugin(name) {
    const prefix = 'piral-cli-';
    return name.startsWith(prefix) && name.length > prefix.length;
}
function isScope(name) {
    const prefix = '@';
    return name.startsWith(prefix) && name.length > prefix.length;
}
function fillPlugins(candidates, plugins) {
    return __awaiter(this, void 0, void 0, function* () {
        yield Promise.all(candidates.map((path) => __awaiter(this, void 0, void 0, function* () {
            if (yield isPluginDirectory(path)) {
                plugins.push(path);
            }
        })));
    });
}
function getAllPlugins(rootDir) {
    return __awaiter(this, void 0, void 0, function* () {
        if (rootDir) {
            (0, common_1.log)('generalDebug_0003', `Getting plugins from dir "${rootDir}" ...`);
            const pluginPaths = yield listDirectory(rootDir);
            const plugins = [];
            const nested = pluginPaths.filter(isScope).map((m) => (0, path_1.join)(rootDir, m));
            yield Promise.all([
                fillPlugins(pluginPaths.filter(isPlugin).map((m) => (0, path_1.join)(rootDir, m)), plugins),
                ...nested.map((path) => __awaiter(this, void 0, void 0, function* () {
                    const files = yield listDirectory(path);
                    yield fillPlugins(files.filter(isPlugin).map((m) => (0, path_1.join)(path, m)), plugins);
                })),
            ]);
            return plugins;
        }
        else {
            (0, common_1.log)('generalDebug_0003', `Skipping plugins from dir "${rootDir}" ...`);
            return [];
        }
    });
}
function loadPlugins() {
    return __awaiter(this, void 0, void 0, function* () {
        const localDir = yield getLocalPackageDir();
        const allPlugins = yield getAllPlugins(localDir);
        for (const pluginPath of allPlugins) {
            (0, inject_1.inject)(pluginPath);
        }
    });
}
exports.loadPlugins = loadPlugins;
//# sourceMappingURL=plugin.js.map