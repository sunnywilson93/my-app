"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.callDebugPiralFromMonoRepo = exports.callPiletBuild = exports.callPiralBuild = exports.callPiletDebug = exports.callPiralDebug = exports.setBundler = void 0;
const bundler_calls_1 = require("./build/bundler-calls");
const helpers_1 = require("./helpers");
const common_1 = require("./common");
const bundlers = [];
function installDefaultBundler(root) {
    return __awaiter(this, void 0, void 0, function* () {
        const selectedBundler = common_1.config.bundler || 'webpack';
        (0, common_1.log)('generalDebug_0003', `Installation of default bundler for "${selectedBundler}".`);
        const selectedPackage = `piral-cli-${selectedBundler}`;
        (0, common_1.log)('generalDebug_0003', `Determining npm client at "${root}" ...`);
        const client = yield (0, common_1.determineNpmClient)(root);
        (0, common_1.log)('generalDebug_0003', `Prepare to install ${selectedPackage}@${common_1.cliVersion} using "${client}" into "${root}".`);
        (0, common_1.progress)(`Installing ${selectedPackage} ...`);
        yield (0, common_1.installNpmPackage)(client, `${selectedPackage}@${common_1.cliVersion}`, root, '--save-dev', '--save-exact');
        (0, common_1.log)('generalDebug_0003', `Installed bundler from "${selectedPackage}".`);
        require('./inject').inject(selectedPackage);
    });
}
function checkDefaultBundler(bundler) {
    if (!(bundler === null || bundler === void 0 ? void 0 : bundler.actions)) {
        (0, common_1.fail)('defaultBundlerMissing_0173');
    }
    return bundler;
}
function checkCustomBundler(bundler, bundlerName) {
    if (!(bundler === null || bundler === void 0 ? void 0 : bundler.actions)) {
        (0, common_1.fail)('bundlerMissing_0172', bundlerName, helpers_1.availableBundlers);
    }
    return bundler;
}
function findBundler(root, bundlerName) {
    return __awaiter(this, void 0, void 0, function* () {
        const [defaultBundler] = bundlers;
        if (bundlerName) {
            const [bundler] = bundlers.filter((m) => m.name === bundlerName);
            return checkCustomBundler(bundler, bundlerName);
        }
        else if (!defaultBundler) {
            yield installDefaultBundler(root);
            const [bundler] = bundlers;
            return checkDefaultBundler(bundler);
        }
        else if (bundlers.length > 1) {
            (0, common_1.log)('bundlerUnspecified_0175', helpers_1.availableBundlers);
        }
        return defaultBundler;
    });
}
function prepareArgs(bundler, args) {
    return __awaiter(this, void 0, void 0, function* () {
        if (args.optimizeModules) {
            (0, common_1.progress)('Preparing modules ...');
            yield (0, common_1.patchModules)(args.root, args.ignored);
            (0, common_1.logReset)();
        }
        if (bundler.prepare) {
            return yield bundler.prepare(args);
        }
        return args;
    });
}
function setBundler(bundler) {
    bundlers.push(bundler);
    if (!helpers_1.availableBundlers.includes(bundler.name)) {
        helpers_1.availableBundlers.push(bundler.name);
    }
}
exports.setBundler = setBundler;
function callPiralDebug(args, bundlerName) {
    return __awaiter(this, void 0, void 0, function* () {
        const bundler = yield findBundler(args.root, bundlerName);
        try {
            const action = bundler.actions.debugPiral;
            const params = yield prepareArgs(action, args);
            return yield (0, bundler_calls_1.callDynamic)('debug-piral', action.path, params);
        }
        catch (err) {
            (0, common_1.fail)('bundlingFailed_0174', err);
        }
    });
}
exports.callPiralDebug = callPiralDebug;
function callPiletDebug(args, bundlerName) {
    return __awaiter(this, void 0, void 0, function* () {
        const bundler = yield findBundler(args.root, bundlerName);
        try {
            const action = bundler.actions.debugPilet;
            const params = yield prepareArgs(action, args);
            return yield (0, bundler_calls_1.callDynamic)('debug-pilet', action.path, params);
        }
        catch (err) {
            (0, common_1.fail)('bundlingFailed_0174', err);
        }
    });
}
exports.callPiletDebug = callPiletDebug;
function callPiralBuild(args, bundlerName) {
    return __awaiter(this, void 0, void 0, function* () {
        const bundler = yield findBundler(args.root, bundlerName);
        try {
            const action = bundler.actions.buildPiral;
            const params = yield prepareArgs(action, args);
            const instance = yield (0, bundler_calls_1.callStatic)('build-piral', action.path, params);
            return instance.bundle;
        }
        catch (err) {
            (0, common_1.fail)('bundlingFailed_0174', err);
        }
    });
}
exports.callPiralBuild = callPiralBuild;
function callPiletBuild(args, bundlerName) {
    return __awaiter(this, void 0, void 0, function* () {
        const bundler = yield findBundler(args.root, bundlerName);
        try {
            const action = bundler.actions.buildPilet;
            const params = yield prepareArgs(action, args);
            const instance = yield (0, bundler_calls_1.callStatic)('build-pilet', action.path, params);
            return instance.bundle;
        }
        catch (err) {
            (0, common_1.fail)('bundlingFailed_0174', err);
        }
    });
}
exports.callPiletBuild = callPiletBuild;
function callDebugPiralFromMonoRepo(args, bundlerName) {
    return __awaiter(this, void 0, void 0, function* () {
        const bundler = yield findBundler(args.root, bundlerName);
        try {
            const action = bundler.actions.watchPiral;
            const params = yield prepareArgs(action, args);
            const instance = yield (0, bundler_calls_1.callStatic)('debug-mono-piral', action.path, params);
            return instance.bundle;
        }
        catch (err) {
            (0, common_1.fail)('bundlingFailed_0174', err);
        }
    });
}
exports.callDebugPiralFromMonoRepo = callDebugPiralFromMonoRepo;
//# sourceMappingURL=bundler.js.map