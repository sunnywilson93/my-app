"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.packageEmulator = exports.createEmulatorSources = void 0;
const path_1 = require("path");
const package_1 = require("./package");
const template_1 = require("./template");
const constants_1 = require("./constants");
const info_1 = require("./info");
const npm_1 = require("./npm");
const declaration_1 = require("./declaration");
const enums_1 = require("./enums");
const archive_1 = require("./archive");
const io_1 = require("./io");
const packageJson = 'package.json';
function createEmulatorSources(sourceDir, targetDir, targetFile, logLevel) {
    var _a, _b, _c, _d, _e;
    return __awaiter(this, void 0, void 0, function* () {
        const piralPkg = require((0, path_1.resolve)(sourceDir, packageJson));
        const files = (_b = (_a = piralPkg.pilets) === null || _a === void 0 ? void 0 : _a.files) !== null && _b !== void 0 ? _b : [];
        const allDeps = Object.assign(Object.assign({}, piralPkg.devDependencies), piralPkg.dependencies);
        const allExternals = (0, npm_1.makeExternals)(sourceDir, allDeps, (_c = piralPkg.pilets) === null || _c === void 0 ? void 0 : _c.externals);
        const externalPackages = yield Promise.all(allExternals.filter(package_1.isValidDependency).map((name) => __awaiter(this, void 0, void 0, function* () {
            return ({
                name,
                version: yield (0, package_1.findDependencyVersion)(piralPkg, sourceDir, name),
            });
        })));
        const externalDependencies = externalPackages.reduce((deps, dep) => {
            deps[dep.name] = dep.version;
            return deps;
        }, {});
        const rootDir = (0, path_1.resolve)(targetDir, '..');
        const appDir = (0, path_1.relative)(rootDir, targetDir);
        const filesDir = (0, path_1.resolve)(rootDir, constants_1.filesTar);
        const filesOnceDir = (0, path_1.resolve)(rootDir, constants_1.filesOnceTar);
        const filesMap = files
            .filter((file) => file && (typeof file === 'string' || typeof file === 'object'))
            .map((file) => (typeof file === 'string' ? { from: file, to: file } : file))
            .filter((file) => typeof file.to === 'string' && typeof file.from === 'string')
            .map((file) => (Object.assign(Object.assign({}, file), { to: file.to.replace(/\\/g, '/'), from: (0, path_1.join)('files', file.to).replace(/\\/g, '/') })));
        // do not modify an existing JSON
        yield (0, io_1.createFileIfNotExists)(rootDir, packageJson, '{}');
        // patch the JSON relevant for th eproject
        yield (0, io_1.updateExistingJson)(rootDir, packageJson, {
            name: piralPkg.name,
            description: piralPkg.description,
            version: piralPkg.version,
            license: piralPkg.license,
            homepage: piralPkg.homepage,
            keywords: piralPkg.keywords,
            pilets: Object.assign(Object.assign({}, piralPkg.pilets), { files: filesMap }),
            piralCLI: {
                version: info_1.cliVersion,
                generated: true,
            },
            main: `./${appDir}/index.js`,
            typings: `./${appDir}/index.d.ts`,
            app: `./${appDir}/index.html`,
            peerDependencies: {},
            devDependencies: Object.assign(Object.assign({}, allDeps), externalDependencies),
            sharedDependencies: allExternals,
            repository: piralPkg.repository,
            bugs: piralPkg.bugs,
            author: piralPkg.author,
            contributors: piralPkg.contributors,
            engines: piralPkg.engines,
            cpu: piralPkg.cpu,
            publishConfig: piralPkg.publishConfig,
        });
        yield Promise.all([(0, io_1.createDirectory)(filesDir), (0, io_1.createDirectory)(filesOnceDir)]);
        // for scaffolding we need to keep the files also available in the new package
        yield (0, package_1.copyScaffoldingFiles)(sourceDir, filesDir, files.filter((m) => typeof m === 'string' || !m.once));
        // also to avoid information loss we should store the once-only files separately
        yield (0, package_1.copyScaffoldingFiles)(sourceDir, filesOnceDir, files.filter((m) => typeof m !== 'string' && m.once));
        // we just want to make sure that "files" mentioned in the original package.json are respected in the package
        yield (0, package_1.copyScaffoldingFiles)(sourceDir, rootDir, (_d = piralPkg.files) !== null && _d !== void 0 ? _d : []);
        // actually including this one hints that the app shell should have been included - which is forbidden
        yield (0, template_1.createFileFromTemplateIfNotExists)('piral', targetDir, 'index.js', enums_1.ForceOverwrite.yes, {
            name: piralPkg.name,
            outFile: targetFile,
        });
        // generate the associated index.d.ts
        yield (0, declaration_1.createPiralDeclaration)(sourceDir, (_e = piralPkg.app) !== null && _e !== void 0 ? _e : `./src/index.html`, targetDir, enums_1.ForceOverwrite.yes, logLevel);
        // since things like .gitignore are not properly treated by npm we pack the files (for standard and once only)
        yield Promise.all([
            (0, archive_1.createTarball)(filesDir, rootDir, `${constants_1.filesTar}.tar`),
            (0, archive_1.createTarball)(filesOnceDir, rootDir, `${constants_1.filesOnceTar}.tar`),
        ]);
        // ... and remove the directory
        yield Promise.all([(0, io_1.removeDirectory)(filesDir), (0, io_1.removeDirectory)(filesOnceDir)]);
        return rootDir;
    });
}
exports.createEmulatorSources = createEmulatorSources;
function packageEmulator(rootDir) {
    return __awaiter(this, void 0, void 0, function* () {
        // finally package everything up
        yield (0, npm_1.createNpmPackage)(rootDir);
        // get all files
        const names = yield (0, io_1.getFileNames)(rootDir);
        // cleanup
        yield Promise.all(names
            .filter((name) => !name.endsWith('.tgz'))
            .map((name) => (0, path_1.resolve)(rootDir, name))
            .map((file) => (0, io_1.removeAny)(file)));
    });
}
exports.packageEmulator = packageEmulator;
//# sourceMappingURL=emulator.js.map