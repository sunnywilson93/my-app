"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.scaffoldPiletSourceFiles = exports.getPiletScaffoldData = exports.scaffoldPiralSourceFiles = exports.getPiralScaffoldData = void 0;
const path_1 = require("path");
const npm_1 = require("./npm");
const enums_1 = require("./enums");
const io_1 = require("./io");
const log_1 = require("./log");
function getTemplatePackage(templatePackageName) {
    const idx = templatePackageName.indexOf('@', 1);
    const normalizedName = idx > 0 && !(0, path_1.isAbsolute)(templatePackageName) ? templatePackageName.substring(0, idx) : templatePackageName;
    try {
        return require(normalizedName);
    }
    catch (_a) {
        (0, log_1.fail)('generalError_0002', `Could not find the given template "${templatePackageName}". Package "${normalizedName}" could not be resolved.`);
    }
}
function getTemplateFiles(templatePackageName, registry, root, data, forceOverwrite) {
    return __awaiter(this, void 0, void 0, function* () {
        // debug in monorepo such as "../templates/pilet-template-react/lib/index.js"
        if (templatePackageName.startsWith('.')) {
            templatePackageName = (0, path_1.resolve)(process.cwd(), templatePackageName);
        }
        else {
            if (templatePackageName.indexOf('@', 1) === -1) {
                templatePackageName = `${templatePackageName}@latest`;
            }
            yield (0, npm_1.installNpmPackage)('npm', templatePackageName, __dirname, '--registry', registry);
        }
        const templateRunner = getTemplatePackage(templatePackageName);
        if (typeof templateRunner === 'function') {
            return yield templateRunner(root, data, forceOverwrite);
        }
        else if ('default' in templateRunner && typeof templateRunner.default === 'function') {
            return yield templateRunner.default(root, data, forceOverwrite);
        }
        else {
            (0, log_1.fail)('generalError_0002', `The provided template package "${templatePackageName}" does not export a template factory function.`);
        }
    });
}
function writeFiles(root, files, forceOverwrite) {
    const rootPackage = (0, path_1.resolve)(root, 'package.json');
    return Promise.all(files
        .filter((file) => {
        if (typeof file.path !== 'string') {
            (0, log_1.log)('generalWarning_0001', `The supplied file path ("${file.path}") is not a string. Skipping.`);
            return false;
        }
        else if (typeof file.content === 'undefined') {
            (0, log_1.log)('generalWarning_0001', `The file "${file.path}" did not specify any content. Skipping.`);
            return false;
        }
        return true;
    })
        .map((file) => {
        const target = (0, path_1.resolve)(root, file.path);
        const name = (0, path_1.basename)(target);
        const dir = (0, path_1.dirname)(target);
        if (target !== rootPackage) {
            return (0, io_1.createFileIfNotExists)(dir, name, file.content, forceOverwrite);
        }
        else {
            return (0, io_1.updateExistingJson)(dir, name, JSON.parse(file.content.toString('utf8')));
        }
    }));
}
function getTemplatePackageName(type, template) {
    if (template.indexOf('/') === -1 && !template.startsWith('.')) {
        return `@smapiot/${type}-template-${template}`;
    }
    return template;
}
function getLanguageName(language) {
    switch (language) {
        case enums_1.SourceLanguage.js:
            return 'js';
        case enums_1.SourceLanguage.ts:
        default:
            return 'ts';
    }
}
function getPiralScaffoldData(language, root, app, packageName, variables) {
    const src = (0, path_1.dirname)((0, path_1.join)(root, app));
    return Object.assign(Object.assign({}, variables), { root,
        src, language: getLanguageName(language), packageName });
}
exports.getPiralScaffoldData = getPiralScaffoldData;
function scaffoldPiralSourceFiles(template, registry, data, forceOverwrite) {
    return __awaiter(this, void 0, void 0, function* () {
        const { src, root } = data;
        const templatePackageName = getTemplatePackageName('piral', template);
        yield (0, io_1.createDirectory)(src);
        const files = yield getTemplateFiles(templatePackageName, registry, root, data, forceOverwrite);
        yield writeFiles(root, files, forceOverwrite);
    });
}
exports.scaffoldPiralSourceFiles = scaffoldPiralSourceFiles;
function getPiletScaffoldData(language, root, sourceName, variables) {
    const src = (0, path_1.join)(root, 'src');
    return Object.assign(Object.assign({}, variables), { root,
        src, language: getLanguageName(language), sourceName });
}
exports.getPiletScaffoldData = getPiletScaffoldData;
function scaffoldPiletSourceFiles(template, registry, data, forceOverwrite) {
    return __awaiter(this, void 0, void 0, function* () {
        const { src, root } = data;
        const templatePackageName = getTemplatePackageName('pilet', template);
        yield (0, io_1.createDirectory)(src);
        const files = yield getTemplateFiles(templatePackageName, registry, root, data, forceOverwrite);
        yield writeFiles(root, files, forceOverwrite);
    });
}
exports.scaffoldPiletSourceFiles = scaffoldPiletSourceFiles;
//# sourceMappingURL=scaffold.js.map