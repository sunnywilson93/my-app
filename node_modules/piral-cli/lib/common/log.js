"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.log = exports.fail = exports.logReset = exports.progress = exports.logFail = exports.logWarn = exports.logDone = exports.logVerbose = exports.logDebug = exports.logInfo = exports.setLogLevel = void 0;
const messages = require("../messages");
const path_1 = require("path");
const util_1 = require("util");
const fs_1 = require("fs");
const info_1 = require("./info");
const external_1 = require("../external");
const types_1 = require("../types");
const logger = (() => {
    try {
        const logger = require('@parcel/logger');
        // check to see if this is really right
        if (typeof logger.verbose === 'function') {
            return logger;
        }
    }
    catch (_a) { }
    return require('../external').logger;
})();
// unfortunately, Parcel's support for verbose logging on Windows is broken
if (info_1.isWindows) {
    logger.verbose = function (message) {
        if (this.logLevel < 4) {
            return;
        }
        const currDate = new Date();
        message = `[${currDate.toLocaleTimeString()}]: ${message}`;
        if (this.logLevel > 4) {
            if (!this.logFile) {
                // the critical line is the filename; it must not contain colons!
                const timestamp = currDate.toISOString().replace(/:/g, '');
                const fileName = `parcel-debug-${timestamp}.log`;
                this.logFile = (0, fs_1.createWriteStream)((0, path_1.join)(process.cwd(), fileName));
            }
            this.logFile.write(external_1.stripAnsi.default(message) + '\n');
        }
        this._log(message);
    };
}
function setLogLevel(logLevel) {
    logger.setOptions({ logLevel });
}
exports.setLogLevel = setLogLevel;
function logInfo(message, ...args) {
    const msg = (0, util_1.format)(message, ...args);
    logger.log(msg);
    return msg;
}
exports.logInfo = logInfo;
function logDebug(message, ...args) {
    const msg = (0, util_1.format)(message, ...args);
    logger.verbose(msg);
    return msg;
}
exports.logDebug = logDebug;
function logVerbose(message, ...args) {
    const msg = (0, util_1.format)(message, ...args);
    logger.logLevel > 3 && logger.log(msg);
    return msg;
}
exports.logVerbose = logVerbose;
function logDone(message, ...args) {
    const msg = (0, util_1.format)(message, ...args);
    logger.success(msg);
    return msg;
}
exports.logDone = logDone;
function logWarn(message, ...args) {
    const msg = (0, util_1.format)(message, ...args);
    logger.warn(msg);
    return msg;
}
exports.logWarn = logWarn;
function logFail(message, ...args) {
    const msg = (0, util_1.format)(message, ...args);
    logger.error(msg);
    return msg;
}
exports.logFail = logFail;
function progress(message, ...args) {
    logger.progress((0, util_1.format)(message, ...args));
}
exports.progress = progress;
function logReset() {
    logger.lines = 0;
    logger.stopSpinner();
}
exports.logReset = logReset;
function fail(type, ...args) {
    const message = log(type, ...args);
    const error = new Error(message);
    error.logged = true;
    throw error;
}
exports.fail = fail;
function log(type, ...args) {
    const [level, code, message] = messages[type].apply(this, args);
    switch (level) {
        case types_1.LogLevels.error:
            return logFail(`[%s] ${message}`, code);
        case types_1.LogLevels.warning:
            return logWarn(`[%s] ${message}`, code);
        case types_1.LogLevels.info:
            return logInfo(`[%s] ${message}`, code);
        case types_1.LogLevels.debug:
            return logDebug(`[%s] ${message}`, code);
        case types_1.LogLevels.verbose:
            return logVerbose(`[%s] ${message}`, code);
    }
}
exports.log = log;
//# sourceMappingURL=log.js.map