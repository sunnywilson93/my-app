"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.patchModules = void 0;
const path_1 = require("path");
const log_1 = require("./log");
const patches_1 = require("./patches");
const hash_1 = require("./hash");
const enums_1 = require("./enums");
const io_1 = require("./io");
function patchModule(packageName, rootDir) {
    return __awaiter(this, void 0, void 0, function* () {
        const applyPatchAt = (0, patches_1.getPatch)(packageName);
        if (typeof applyPatchAt === 'function') {
            (0, log_1.log)('generalDebug_0003', `Applying patchers for ${packageName} in "${rootDir}" ...`);
            yield applyPatchAt(rootDir);
        }
    });
}
// See https://github.com/smapiot/piral/issues/121#issuecomment-572055594
const defaultIgnoredPackages = ['core-js'];
/**
 * The motivation for this method came from:
 * https://github.com/parcel-bundler/parcel/issues/1655#issuecomment-568175592
 * General idea:
 * Treat all modules as non-optimized for the current output target.
 * This makes sense in general as only the application should determine the target.
 */
function patch(staticPath, ignoredPackages) {
    return __awaiter(this, void 0, void 0, function* () {
        (0, log_1.log)('generalDebug_0003', `Patching files in "${staticPath}" ...`);
        const folderNames = yield (0, io_1.getFileNames)(staticPath);
        return Promise.all(folderNames.map((folderName) => __awaiter(this, void 0, void 0, function* () {
            if (!ignoredPackages.includes(folderName)) {
                const rootName = (0, path_1.resolve)(staticPath, folderName);
                const isDirectory = yield (0, io_1.checkIsDirectory)(rootName);
                if (isDirectory) {
                    if (folderName.startsWith('@')) {
                        // if we are scoped, just go down
                        yield patch(rootName, ignoredPackages);
                    }
                    else {
                        try {
                            const packageFileData = yield (0, io_1.readJson)(rootName, 'package.json');
                            if (packageFileData.name && packageFileData._piralOptimized === undefined) {
                                packageFileData._piralOptimized = packageFileData.browserslist || true;
                                delete packageFileData.browserslist;
                                yield (0, io_1.writeJson)(rootName, 'package.json', packageFileData, true);
                                yield (0, io_1.writeText)(rootName, '.browserslistrc', 'node 10.11');
                                yield patchModule(folderName, rootName);
                            }
                            yield patchFolder(rootName, ignoredPackages);
                        }
                        catch (e) {
                            (0, log_1.log)('generalDebug_0003', `Encountered a patching error: ${e}`);
                        }
                    }
                }
            }
        })));
    });
}
function patchFolder(rootDir, ignoredPackages) {
    return __awaiter(this, void 0, void 0, function* () {
        const file = '.patched';
        const modulesDir = (0, path_1.resolve)(rootDir, 'node_modules');
        const exists = yield (0, io_1.checkExists)(modulesDir);
        if (exists) {
            const lockContent = (yield (0, io_1.readText)(rootDir, 'package-lock.json')) || (yield (0, io_1.readText)(rootDir, 'yarn.lock'));
            const currHash = (0, hash_1.computeHash)(lockContent);
            const prevHash = yield (0, io_1.readText)(modulesDir, file);
            (0, log_1.log)('generalDebug_0003', `Evaluated patch module hashes: "${currHash}" and "${prevHash}".`);
            if (prevHash !== currHash) {
                yield patch(modulesDir, ignoredPackages);
                yield (0, io_1.createFileIfNotExists)(modulesDir, file, currHash, enums_1.ForceOverwrite.yes);
            }
        }
    });
}
function patchModules(rootDir, ignoredPackages = defaultIgnoredPackages) {
    return __awaiter(this, void 0, void 0, function* () {
        (0, log_1.log)('generalDebug_0003', `Patching modules starting in "${rootDir}" ...`);
        const otherRoot = (0, path_1.resolve)(require.resolve('piral-cli/package.json'), '..', '..', '..');
        yield patchFolder(rootDir, ignoredPackages);
        if (otherRoot !== rootDir) {
            (0, log_1.log)('generalDebug_0003', `Also patching modules in "${otherRoot}" ...`);
            yield patchFolder(otherRoot, ignoredPackages);
        }
    });
}
exports.patchModules = patchModules;
//# sourceMappingURL=patcher.js.map