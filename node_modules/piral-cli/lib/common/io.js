"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getSourceFiles = exports.move = exports.removeFile = exports.remove = exports.copy = exports.updateExistingJson = exports.writeBinary = exports.writeText = exports.writeJson = exports.readText = exports.readBinary = exports.readJson = exports.mergeWithJson = exports.getHash = exports.updateExistingFile = exports.createFileIfNotExists = exports.matchFiles = exports.matchAnyPilet = exports.findFile = exports.getFileNames = exports.checkIsDirectory = exports.checkExistingDirectory = exports.checkExists = exports.getEntryFiles = exports.createDirectory = exports.removeDirectory = exports.removeAny = void 0;
const rimraf = require("rimraf");
const typescript_1 = require("typescript");
const path_1 = require("path");
const fs_1 = require("fs");
const fs_2 = require("fs");
const log_1 = require("./log");
const merge_1 = require("./merge");
const info_1 = require("./info");
const hash_1 = require("./hash");
const enums_1 = require("./enums");
const interactive_1 = require("./interactive");
const external_1 = require("../external");
function promptOverwrite(file) {
    const message = `The file ${file} exists already. Do you want to overwrite it?`;
    return (0, interactive_1.promptConfirm)(message, false);
}
function createDirectoryLegacy(targetDir) {
    const initDir = (0, path_1.isAbsolute)(targetDir) ? path_1.sep : '';
    return targetDir.split(path_1.sep).reduce((parentDir, childDir) => {
        const curDir = (0, path_1.resolve)(parentDir, childDir);
        try {
            (0, fs_1.mkdirSync)(curDir);
        }
        catch (err) {
            if (err.code === 'EEXIST') {
                return curDir;
            }
            if (err.code === 'ENOENT') {
                throw new Error(`EACCES: permission denied, mkdir '${parentDir}'`);
            }
            const caughtErr = ['EACCES', 'EPERM', 'EISDIR'].indexOf(err.code) > -1;
            if (!caughtErr || (caughtErr && curDir === (0, path_1.resolve)(targetDir))) {
                throw err;
            }
        }
        return curDir;
    }, initDir);
}
function isFile(file) {
    return (0, fs_1.statSync)(file).isFile();
}
function isLegacy() {
    const parts = info_1.nodeVersion.split('.');
    return +parts[0] < 10 || (+parts[0] === 10 && +parts[1] < 12);
}
function removeAny(target) {
    return __awaiter(this, void 0, void 0, function* () {
        const isDir = yield checkIsDirectory(target);
        if (isDir) {
            yield removeDirectory(target);
        }
        else {
            yield removeFile(target);
        }
    });
}
exports.removeAny = removeAny;
function removeDirectory(targetDir) {
    (0, log_1.log)('generalDebug_0003', `Removing the directory "${targetDir}" ...`);
    return new Promise((resolve, reject) => rimraf(targetDir, (err) => (err ? reject(err) : resolve())));
}
exports.removeDirectory = removeDirectory;
function createDirectory(targetDir) {
    return __awaiter(this, void 0, void 0, function* () {
        if (isLegacy()) {
            try {
                (0, log_1.log)('generalDebug_0003', `Trying to create "${targetDir}" in legacy mode ...`);
                createDirectoryLegacy(targetDir);
                return true;
            }
            catch (e) {
                (0, log_1.log)('cannotCreateDirectory_0044');
                (0, log_1.log)('generalDebug_0003', `Error while creating ${targetDir}: ${e}`);
                return false;
            }
        }
        try {
            (0, log_1.log)('generalDebug_0003', `Trying to create "${targetDir}" in modern mode ...`);
            yield new Promise((resolve, reject) => {
                (0, fs_1.mkdir)(targetDir, { recursive: true }, (err) => (err ? reject(err) : resolve()));
            });
            return true;
        }
        catch (e) {
            (0, log_1.log)('cannotCreateDirectory_0044');
            (0, log_1.log)('generalDebug_0003', `Error while creating ${targetDir}: ${e}`);
            return false;
        }
    });
}
exports.createDirectory = createDirectory;
function getEntryFiles(content, basePath) {
    return __awaiter(this, void 0, void 0, function* () {
        (0, log_1.log)('generalDebug_0003', `Extract entry files from "${basePath}".`);
        const matcher = /<script\s.*?src=(?:"(.*?)"|'(.*?)'|([^\s>]*)).*?>/gi;
        const results = [];
        let result = undefined;
        while ((result = matcher.exec(content))) {
            const src = result[1] || result[2] || result[3];
            (0, log_1.log)('generalDebug_0003', `Found potential entry file "${src}".`);
            const filePath = (0, path_1.resolve)(basePath, src);
            const exists = yield checkExists(filePath);
            if (exists) {
                results.push(filePath);
            }
        }
        return results;
    });
}
exports.getEntryFiles = getEntryFiles;
function checkExists(target) {
    return new Promise((resolve) => {
        if (target !== undefined) {
            (0, fs_1.exists)(target, resolve);
        }
        else {
            resolve(false);
        }
    });
}
exports.checkExists = checkExists;
function checkExistingDirectory(target) {
    return __awaiter(this, void 0, void 0, function* () {
        (0, log_1.log)('generalDebug_0003', `Checking directory "${target}" ...`);
        if (yield checkExists(target)) {
            (0, log_1.log)('generalDebug_0003', `Target exists, but not yet clear if directory.`);
            return yield checkIsDirectory(target);
        }
        return false;
    });
}
exports.checkExistingDirectory = checkExistingDirectory;
function checkIsDirectory(target) {
    return new Promise((resolve) => {
        (0, fs_1.lstat)(target, (err, stats) => {
            if (err) {
                resolve((0, path_1.extname)(target) === '');
            }
            else {
                resolve(stats.isDirectory());
            }
        });
    });
}
exports.checkIsDirectory = checkIsDirectory;
function getFileNames(target) {
    return new Promise((resolve, reject) => {
        (0, fs_2.readdir)(target, (err, files) => (err ? reject(err) : resolve(files)));
    });
}
exports.getFileNames = getFileNames;
function findFile(topDir, fileName) {
    return __awaiter(this, void 0, void 0, function* () {
        const path = (0, path_1.join)(topDir, fileName);
        const exists = yield checkExists(path);
        if (!exists) {
            const parentDir = (0, path_1.resolve)(topDir, '..');
            if (parentDir !== topDir) {
                return yield findFile(parentDir, fileName);
            }
            return undefined;
        }
        return path;
    });
}
exports.findFile = findFile;
function matchPattern(baseDir, pattern) {
    return new Promise((resolve, reject) => {
        (0, external_1.glob)(pattern, {
            cwd: baseDir,
            nodir: true,
            absolute: true,
        }, (err, files) => {
            if (err) {
                reject(err);
            }
            else {
                resolve(files);
            }
        });
    });
}
function matchAnyPattern(baseDir, pattern) {
    return __awaiter(this, void 0, void 0, function* () {
        const matches = yield Promise.all(pattern.patterns.map((pattern) => matchPattern(baseDir, pattern)));
        return {
            pattern: pattern.original,
            results: matches.reduce((agg, curr) => [...agg, ...curr], []),
        };
    });
}
const preferences = ['.tsx', '.ts', '.jsx', '.js', '.mjs', '.cjs', '.esm', '.es', '.es6', '.html'];
function matchAnyPilet(baseDir, patterns) {
    return __awaiter(this, void 0, void 0, function* () {
        const matches = [];
        const pilets = [];
        const matched = (name, path) => {
            pilets.push(name);
            matches.push(path);
        };
        const nameOfPackageJson = 'package.json';
        const exts = preferences.map((s) => s.substring(1)).join(',');
        const allPatterns = patterns.reduce((agg, curr) => {
            const patterns = [];
            if (/[a-zA-Z0-9\-\*]$/.test(curr) && !preferences.find((ext) => curr.endsWith(ext))) {
                patterns.push(curr, `${curr}.{${exts}}`, `${curr}/${nameOfPackageJson}`);
            }
            else if (curr.endsWith('/')) {
                patterns.push(`${curr}index.{${exts}}`, `${curr}${nameOfPackageJson}`);
            }
            else {
                patterns.push(curr);
            }
            agg.push({ original: curr, patterns });
            return agg;
        }, []);
        yield Promise.all(allPatterns.map((patterns) => matchAnyPattern(baseDir, patterns).then(({ results, pattern }) => __awaiter(this, void 0, void 0, function* () {
            if (!results.length) {
                (0, log_1.log)('generalDebug_0003', `Found no potential entry points using "${pattern}".`);
            }
            else {
                //TODO -> shouldn't take the first one,
                // should be the first one, yes, but, PER pilet
                // so that multiple pilets can be considered, too
                (0, log_1.log)('generalDebug_0003', `Found ${results.length} potential entry points in "${pattern}".`);
                for (const result of results) {
                    const fileName = (0, path_1.basename)(result);
                    if (fileName === nameOfPackageJson) {
                        (0, log_1.log)('generalDebug_0003', `Entry point is a "${nameOfPackageJson}" and needs further inspection.`);
                        const targetDir = (0, path_1.dirname)(result);
                        const { source, name } = yield readJson(targetDir, fileName);
                        if (!pilets.includes(name)) {
                            if (typeof source === 'string') {
                                (0, log_1.log)('generalDebug_0003', `Found a "source" field with value "${source}".`);
                                const target = (0, path_1.resolve)(targetDir, source);
                                const exists = yield checkExists(target);
                                if (exists) {
                                    (0, log_1.log)('generalDebug_0003', `Taking existing target as "${target}".`);
                                    matched(name, target);
                                }
                                else {
                                    (0, log_1.log)('generalDebug_0003', `Source target "${target}" does not exist. Skipped.`);
                                }
                            }
                            else {
                                (0, log_1.log)('generalDebug_0003', `No "source" field found. Trying combinations in "src".`);
                                const files = yield matchPattern(targetDir, `src/index.{${exts}}`);
                                if (files.length > 0) {
                                    (0, log_1.log)('generalDebug_0003', `Found a result; taking "${files[0]}".`);
                                    matched(name, files[0]);
                                }
                                else {
                                    (0, log_1.log)('generalDebug_0003', `Found no results in "src". Skipped.`);
                                }
                            }
                        }
                    }
                    else {
                        const packageJson = yield findFile(result, nameOfPackageJson);
                        if (packageJson) {
                            const targetDir = (0, path_1.dirname)(packageJson);
                            const { name } = yield readJson(targetDir, nameOfPackageJson);
                            if (!pilets.includes(name)) {
                                (0, log_1.log)('generalDebug_0003', `Entry point result is "${result}".`);
                                matched(name, result);
                            }
                        }
                        else {
                            (0, log_1.log)('generalDebug_0003', `Could not find "${nameOfPackageJson}" for entry "${result}". Skipping.`);
                        }
                    }
                }
            }
        }))));
        return matches;
    });
}
exports.matchAnyPilet = matchAnyPilet;
function matchFiles(baseDir, pattern) {
    return new Promise((resolve, reject) => {
        (0, external_1.glob)(pattern, {
            cwd: baseDir,
            absolute: true,
            dot: true,
        }, (err, files) => {
            if (err) {
                reject(err);
            }
            else {
                resolve(files.filter(isFile));
            }
        });
    });
}
exports.matchFiles = matchFiles;
function createFileIfNotExists(targetDir, fileName, content, forceOverwrite = enums_1.ForceOverwrite.no) {
    return __awaiter(this, void 0, void 0, function* () {
        const targetFile = (0, path_1.join)(targetDir, fileName);
        (0, log_1.log)('generalDebug_0003', `Checking if file "${targetFile}" exists ...`);
        const exists = yield checkExists(targetFile);
        if (!exists ||
            forceOverwrite === enums_1.ForceOverwrite.yes ||
            (forceOverwrite === enums_1.ForceOverwrite.prompt && (yield promptOverwrite(targetFile)))) {
            yield createDirectory((0, path_1.dirname)(targetFile));
            (0, log_1.log)('generalDebug_0003', `Creating file "${targetFile}" ...`);
            if (typeof content === 'string') {
                yield writeText(targetDir, fileName, content);
            }
            else {
                yield writeBinary(targetDir, fileName, content);
            }
        }
    });
}
exports.createFileIfNotExists = createFileIfNotExists;
function updateExistingFile(targetDir, fileName, content) {
    return __awaiter(this, void 0, void 0, function* () {
        const targetFile = (0, path_1.join)(targetDir, fileName);
        (0, log_1.log)('generalDebug_0003', `Checking if file "${targetFile}" exists ...`);
        const exists = yield checkExists(targetFile);
        if (exists) {
            (0, log_1.log)('generalDebug_0003', `Updating file "${targetFile}" ...`);
            yield new Promise((resolve, reject) => {
                (0, fs_2.writeFile)(targetFile, content, 'utf8', (err) => (err ? reject(err) : resolve()));
            });
        }
    });
}
exports.updateExistingFile = updateExistingFile;
function getHash(targetFile) {
    return __awaiter(this, void 0, void 0, function* () {
        return new Promise((resolve) => {
            (0, fs_2.readFile)(targetFile, (err, c) => (err ? resolve(undefined) : resolve((0, hash_1.computeHash)(c))));
        });
    });
}
exports.getHash = getHash;
function mergeWithJson(targetDir, fileName, newContent) {
    return __awaiter(this, void 0, void 0, function* () {
        const targetFile = (0, path_1.join)(targetDir, fileName);
        const content = yield new Promise((resolve, reject) => {
            (0, fs_2.readFile)(targetFile, 'utf8', (err, c) => (err ? reject(err) : resolve(c)));
        });
        const originalContent = JSON.parse(content);
        return (0, merge_1.deepMerge)(originalContent, newContent);
    });
}
exports.mergeWithJson = mergeWithJson;
function readJson(targetDir, fileName) {
    return __awaiter(this, void 0, void 0, function* () {
        const targetFile = (0, path_1.join)(targetDir, fileName);
        const content = yield new Promise((resolve) => {
            (0, fs_2.readFile)(targetFile, 'utf8', (err, c) => (err ? resolve('') : resolve(c)));
        });
        return JSON.parse(content || '{}');
    });
}
exports.readJson = readJson;
function readBinary(targetDir, fileName) {
    const targetFile = (0, path_1.join)(targetDir, fileName);
    return new Promise((resolve) => {
        (0, fs_2.readFile)(targetFile, (err, c) => (err ? resolve(undefined) : resolve(c)));
    });
}
exports.readBinary = readBinary;
function readText(targetDir, fileName) {
    const targetFile = (0, path_1.join)(targetDir, fileName);
    return new Promise((resolve) => {
        (0, fs_2.readFile)(targetFile, 'utf8', (err, c) => (err ? resolve(undefined) : resolve(c)));
    });
}
exports.readText = readText;
function writeJson(targetDir, fileName, data, beautify = false) {
    const content = beautify ? JSON.stringify(data, undefined, 2) : JSON.stringify(data);
    return writeText(targetDir, fileName, content);
}
exports.writeJson = writeJson;
function writeText(targetDir, fileName, content) {
    const data = Buffer.from(content, 'utf8');
    return writeBinary(targetDir, fileName, data);
}
exports.writeText = writeText;
function writeBinary(targetDir, fileName, data) {
    const targetFile = (0, path_1.join)(targetDir, fileName);
    return new Promise((resolve, reject) => {
        (0, fs_2.writeFile)(targetFile, data, (err) => (err ? reject(err) : resolve()));
    });
}
exports.writeBinary = writeBinary;
function updateExistingJson(targetDir, fileName, newContent) {
    return __awaiter(this, void 0, void 0, function* () {
        const content = yield mergeWithJson(targetDir, fileName, newContent);
        yield updateExistingFile(targetDir, fileName, JSON.stringify(content, undefined, 2));
    });
}
exports.updateExistingJson = updateExistingJson;
function copy(source, target, forceOverwrite = enums_1.ForceOverwrite.no) {
    return __awaiter(this, void 0, void 0, function* () {
        yield createDirectory((0, path_1.dirname)(target));
        try {
            const flag = forceOverwrite === enums_1.ForceOverwrite.yes ? 0 : fs_2.constants.COPYFILE_EXCL;
            const isDir = yield checkIsDirectory(source);
            if (isDir) {
                const files = yield getFileNames(source);
                const results = yield Promise.all(files.map((file) => copy((0, path_1.resolve)(source, file), (0, path_1.resolve)(target, file), forceOverwrite)));
                return results.every(Boolean);
            }
            else {
                yield new Promise((resolve, reject) => {
                    (0, fs_2.copyFile)(source, target, flag, (err) => (err ? reject(err) : resolve()));
                });
                return true;
            }
        }
        catch (e) {
            if (forceOverwrite === enums_1.ForceOverwrite.prompt) {
                const shouldOverwrite = yield promptOverwrite(target);
                if (shouldOverwrite) {
                    return yield copy(source, target, enums_1.ForceOverwrite.yes);
                }
            }
            else {
                (0, log_1.log)('didNotOverWriteFile_0045', target);
            }
        }
        return false;
    });
}
exports.copy = copy;
/**
 * @deprecated Will be removed with v1. Please use "removeFile".
 */
function remove(target) {
    return removeFile(target);
}
exports.remove = remove;
function removeFile(target) {
    return new Promise((resolve, reject) => {
        (0, fs_1.unlink)(target, (err) => {
            if (err) {
                reject(err);
            }
            else {
                resolve();
            }
        });
    });
}
exports.removeFile = removeFile;
function move(source, target, forceOverwrite = enums_1.ForceOverwrite.no) {
    return __awaiter(this, void 0, void 0, function* () {
        const dir = yield checkIsDirectory(target);
        if (dir) {
            const file = (0, path_1.basename)(source);
            target = (0, path_1.resolve)(target, file);
        }
        const success = yield copy(source, target, forceOverwrite);
        if (success) {
            yield removeFile(source);
            return target;
        }
        return source;
    });
}
exports.move = move;
function getSourceFiles(entry) {
    return __awaiter(this, void 0, void 0, function* () {
        const dir = (0, path_1.dirname)(entry);
        (0, log_1.log)('generalDebug_0003', `Trying to get source files from "${dir}" ...`);
        const files = yield matchFiles(dir, '**/*.?(jsx|tsx|js|ts)');
        return files.map((path) => {
            const directory = (0, path_1.dirname)(path);
            const name = (0, path_1.basename)(path);
            return {
                path,
                directory,
                name,
                read() {
                    return __awaiter(this, void 0, void 0, function* () {
                        const content = yield readText(directory, name);
                        if (name.endsWith('.ts') || name.endsWith('.tsx')) {
                            return (0, typescript_1.transpileModule)(content, {
                                fileName: path,
                                moduleName: name,
                                compilerOptions: {
                                    allowJs: true,
                                    skipLibCheck: true,
                                    declaration: false,
                                    sourceMap: false,
                                    checkJs: false,
                                    jsx: typescript_1.JsxEmit.React,
                                    module: typescript_1.ModuleKind.ESNext,
                                    moduleResolution: typescript_1.ModuleResolutionKind.NodeJs,
                                    target: typescript_1.ScriptTarget.ESNext,
                                },
                            }).outputText;
                        }
                        return content;
                    });
                },
            };
        });
    });
}
exports.getSourceFiles = getSourceFiles;
//# sourceMappingURL=io.js.map