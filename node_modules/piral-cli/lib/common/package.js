"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.retrievePiletData = exports.readImportmap = exports.checkAppShellPackage = exports.patchPiletPackage = exports.isValidDependency = exports.retrievePiletsInfo = exports.findPackageVersion = exports.findDependencyVersion = exports.retrievePiralRoot = exports.getPiletsInfo = exports.copyPiralFiles = exports.copyScaffoldingFiles = exports.getFileStats = exports.getPiralPackage = exports.readPiralPackage = exports.findPackageRoot = exports.getPiralPath = void 0;
const path_1 = require("path");
const log_1 = require("./log");
const info_1 = require("./info");
const archive_1 = require("./archive");
const language_1 = require("./language");
const enums_1 = require("./enums");
const compatibility_1 = require("./compatibility");
const merge_1 = require("./merge");
const hash_1 = require("./hash");
const template_1 = require("./template");
const npm_1 = require("./npm");
const constants_1 = require("./constants");
const io_1 = require("./io");
const io_2 = require("./io");
function appendBundler(devDependencies, bundler, version) {
    if (bundler && bundler !== 'none') {
        if (constants_1.bundlerNames.includes(bundler)) {
            devDependencies[`piral-cli-${bundler}`] = version;
        }
        else if (!isValidDependency(bundler)) {
            //Error case - print warning and ignore
            (0, log_1.log)('generalWarning_0001', `The provided bundler name "${bundler}" does not refer to a valid package name.'`);
        }
        else {
            const sep = bundler.indexOf('@', 1);
            const name = bundler.substring(0, sep !== -1 ? sep : bundler.length);
            const version = sep !== -1 ? bundler.substring(sep + 1) : 'latest';
            devDependencies[name] = version;
        }
    }
}
function getDependencyVersion(name, devDependencies, allDependencies) {
    const version = devDependencies[name];
    const selected = typeof version === 'string' ? version : version === true ? allDependencies[name] : undefined;
    if (!selected) {
        (0, log_1.log)('cannotResolveVersion_0052', name);
    }
    return selected || 'latest';
}
const globPatternStartIndicators = ['*', '?', '[', '!(', '?(', '+(', '@('];
function getMatchingFiles(source, target, file) {
    return __awaiter(this, void 0, void 0, function* () {
        const { from, to, deep = true, template = false, } = typeof file === 'string' ? { from: file, to: file, deep: true } : file;
        const sourcePath = (0, path_1.resolve)(source, from);
        const targetPath = (0, path_1.resolve)(target, to);
        const isDirectory = yield (0, io_1.checkIsDirectory)(sourcePath);
        if (isDirectory) {
            (0, log_1.log)('generalDebug_0003', `Matching in directory "${sourcePath}".`);
            const pattern = deep ? '**/*' : '*';
            const files = yield (0, io_1.matchFiles)(sourcePath, pattern);
            return files.map((file) => ({
                sourcePath: file,
                targetPath: (0, path_1.resolve)(targetPath, (0, path_1.relative)(sourcePath, file)),
                template,
            }));
        }
        else if (globPatternStartIndicators.some((m) => from.indexOf(m) !== -1)) {
            (0, log_1.log)('generalDebug_0003', `Matching using glob "${sourcePath}".`);
            const files = yield (0, io_1.matchFiles)(source, from);
            const parts = sourcePath.split('/');
            for (let i = 0; i < parts.length; i++) {
                const part = parts[i];
                if (globPatternStartIndicators.some((m) => part.indexOf(m) !== -1)) {
                    parts.splice(i, parts.length - i);
                    break;
                }
            }
            const relRoot = parts.join('/');
            const tarRoot = (0, path_1.resolve)(target, to);
            return files.map((file) => ({
                sourcePath: file,
                targetPath: (0, path_1.resolve)(tarRoot, (0, path_1.relative)(relRoot, file)),
                template,
            }));
        }
        (0, log_1.log)('generalDebug_0003', `Assume direct path source "${sourcePath}".`);
        return [
            {
                sourcePath,
                targetPath,
                template,
            },
        ];
    });
}
function getPiralPath(root, name) {
    try {
        const path = require.resolve(`${name}/package.json`, {
            paths: [root],
        });
        return (0, path_1.dirname)(path);
    }
    catch (ex) {
        (0, log_1.log)('generalDebug_0003', `Could not resolve the Piral path of "${name}" in "${root}": ${ex}.`);
        (0, log_1.fail)('invalidPiralReference_0043');
    }
}
exports.getPiralPath = getPiralPath;
function findPackageRoot(pck, baseDir) {
    try {
        return require.resolve(`${pck}/package.json`, {
            paths: [baseDir],
        });
    }
    catch (ex) {
        (0, log_1.log)('generalDebug_0003', `Could not find the package root in "${baseDir}": ${ex}.`);
        return undefined;
    }
}
exports.findPackageRoot = findPackageRoot;
function findPackage(pck, baseDir) {
    if (Array.isArray(pck)) {
        for (const item of pck) {
            const result = findPackage(item, baseDir);
            if (result) {
                return result;
            }
        }
    }
    else {
        const path = findPackageRoot(pck, baseDir);
        if (path) {
            (0, log_1.log)('generalDebug_0003', `Following the app package in "${path}" ...`);
            const appPackage = require(path);
            const relPath = appPackage && appPackage.app;
            appPackage.app = relPath && (0, path_1.resolve)((0, path_1.dirname)(path), relPath);
            return appPackage;
        }
    }
    return undefined;
}
function readPiralPackage(root, name) {
    (0, log_1.log)('generalDebug_0003', `Reading the piral package in "${root}" ...`);
    const path = getPiralPath(root, name);
    return (0, io_2.readJson)(path, 'package.json');
}
exports.readPiralPackage = readPiralPackage;
function getPiralPackage(app, language, version, framework, bundler) {
    // take default packages only if piral-core
    const packages = framework !== 'piral-core' ? {} : undefined;
    // take default dev packages only if not piral-base
    const typings = framework === 'piral-base' ? {} : undefined;
    const devDependencies = Object.assign(Object.assign({}, (0, language_1.getDevDependencies)(language, typings)), { 'piral-cli': `${version}` });
    const dependencies = Object.assign({}, (0, language_1.getDependencies)(language, packages));
    appendBundler(devDependencies, bundler, version);
    return {
        app,
        scripts: {
            start: 'piral debug',
            build: 'piral build',
        },
        pilets: getPiletsInfo({}),
        dependencies,
        devDependencies,
    };
}
exports.getPiralPackage = getPiralPackage;
function getAvailableFiles(root, name, dirName, fileMap) {
    return __awaiter(this, void 0, void 0, function* () {
        const source = getPiralPath(root, name);
        const tgz = `${dirName}.tar`;
        (0, log_1.log)('generalDebug_0003', `Checking if "${tgz}" exists in "${source}" ...`);
        const exists = yield (0, io_2.checkExists)((0, path_1.resolve)(source, tgz));
        if (exists) {
            yield (0, archive_1.unpackTarball)(source, tgz);
        }
        (0, log_1.log)('generalDebug_0003', `Get matching files from "${source}".`);
        const base = (0, path_1.resolve)(source, dirName);
        const files = yield (0, io_1.matchFiles)(base, '**/*');
        return files.map((file) => {
            var _a;
            return ({
                sourcePath: file,
                targetPath: (0, path_1.resolve)(root, (0, path_1.relative)(base, file)),
                template: ((_a = fileMap.find((m) => (0, path_1.resolve)(source, m.from) === file)) === null || _a === void 0 ? void 0 : _a.template) || false,
            });
        });
    });
}
function getFileStats(root, name, fileMap = []) {
    return __awaiter(this, void 0, void 0, function* () {
        const files = yield getAvailableFiles(root, name, constants_1.filesTar, fileMap);
        return yield Promise.all(files.map((file) => __awaiter(this, void 0, void 0, function* () {
            const { sourcePath, targetPath } = file;
            const sourceHash = yield (0, io_1.getHash)(sourcePath);
            (0, log_1.log)('generalDebug_0003', `Obtained hash from "${sourcePath}": ${sourceHash}`);
            const targetHash = yield (0, io_1.getHash)(targetPath);
            (0, log_1.log)('generalDebug_0003', `Obtained hash from "${targetPath}": ${targetHash}`);
            return {
                path: targetPath,
                hash: targetHash,
                changed: sourceHash !== targetHash,
            };
        })));
    });
}
exports.getFileStats = getFileStats;
function copyFiles(subfiles, forceOverwrite, originalFiles, variables) {
    return __awaiter(this, void 0, void 0, function* () {
        for (const subfile of subfiles) {
            const { sourcePath, targetPath, template } = subfile;
            const exists = yield (0, io_2.checkExists)(sourcePath);
            if (exists) {
                const overwrite = originalFiles.some((m) => m.path === targetPath && !m.changed);
                const force = overwrite ? enums_1.ForceOverwrite.yes : forceOverwrite;
                const written = yield (0, io_2.copy)(sourcePath, targetPath, force);
                if (written && template && variables) {
                    yield (0, template_1.applyTemplate)(targetPath, variables);
                }
            }
            else {
                (0, log_1.fail)('cannotFindFile_0046', sourcePath);
            }
        }
    });
}
function copyScaffoldingFiles(source, target, files, piralInfo, variables) {
    return __awaiter(this, void 0, void 0, function* () {
        (0, log_1.log)('generalDebug_0003', `Copying the scaffolding files ...`);
        const allFiles = [];
        for (const file of files) {
            const subfiles = yield getMatchingFiles(source, target, file);
            allFiles.push(...subfiles);
        }
        if (piralInfo) {
            yield extendPackageOverridesFromTemplateFragment(target, piralInfo, allFiles);
        }
        yield copyFiles(allFiles, enums_1.ForceOverwrite.yes, [], variables);
    });
}
exports.copyScaffoldingFiles = copyScaffoldingFiles;
function extendPackageOverridesFromTemplateFragment(root, piralInfo, files) {
    return __awaiter(this, void 0, void 0, function* () {
        const packageTarget = (0, path_1.resolve)(root, 'package.json');
        for (let i = files.length; i--;) {
            const file = files[i];
            if (file.targetPath === packageTarget) {
                const fragment = yield (0, io_2.readJson)((0, path_1.dirname)(file.sourcePath), (0, path_1.basename)(file.sourcePath));
                files.splice(i, 1);
                if (!piralInfo.pilets) {
                    piralInfo.pilets = {};
                }
                if (!piralInfo.pilets.packageOverrides) {
                    piralInfo.pilets.packageOverrides = {};
                }
                piralInfo.pilets.packageOverrides = Object.assign(Object.assign({}, piralInfo.pilets.packageOverrides), fragment);
            }
        }
    });
}
function isTemplateFileLocation(item) {
    return typeof item === 'object';
}
function tryFindPackageVersion(packageName) {
    try {
        const { version } = require(`${packageName}/package.json`);
        return version;
    }
    catch (_a) {
        return undefined;
    }
}
function copyPiralFiles(root, name, piralInfo, forceOverwrite, variables, originalFiles) {
    return __awaiter(this, void 0, void 0, function* () {
        (0, log_1.log)('generalDebug_0003', `Copying the Piral files ...`);
        const { files: _files } = getPiletsInfo(piralInfo);
        const fileMap = _files.filter(isTemplateFileLocation);
        const files = yield getAvailableFiles(root, name, constants_1.filesTar, fileMap);
        if (originalFiles === undefined) {
            const initialFiles = yield getAvailableFiles(root, name, constants_1.filesOnceTar, fileMap);
            files.push(...initialFiles);
            originalFiles = [];
        }
        yield extendPackageOverridesFromTemplateFragment(root, piralInfo, files);
        yield copyFiles(files, forceOverwrite, originalFiles, variables);
    });
}
exports.copyPiralFiles = copyPiralFiles;
function getPiletsInfo(piralInfo) {
    const { files = [], externals = [], scripts = {}, template = 'default', validators = {}, devDependencies = {}, preScaffold = '', postScaffold = '', preUpgrade = '', postUpgrade = '', packageOverrides = {}, } = piralInfo.pilets || {};
    return {
        files,
        externals,
        scripts,
        template,
        validators,
        devDependencies,
        preScaffold,
        postScaffold,
        preUpgrade,
        postUpgrade,
        packageOverrides,
    };
}
exports.getPiletsInfo = getPiletsInfo;
function retrievePiralRoot(baseDir, entry) {
    return __awaiter(this, void 0, void 0, function* () {
        const rootDir = (0, path_1.join)(baseDir, entry);
        (0, log_1.log)('generalDebug_0003', `Retrieving Piral root from "${rootDir}" ...`);
        if (!constants_1.declarationEntryExtensions.includes((0, path_1.extname)(rootDir).toLowerCase())) {
            const packageName = (0, path_1.basename)(rootDir) === 'package.json' ? rootDir : (0, path_1.join)(rootDir, 'package.json');
            (0, log_1.log)('generalDebug_0003', `Trying to get entry point from "${packageName}".`);
            const exists = yield (0, io_2.checkExists)(packageName);
            if (!exists) {
                (0, log_1.fail)('entryPointMissing_0070', rootDir);
            }
            const { app } = require(packageName);
            if (!app) {
                (0, log_1.fail)('entryPointMissing_0071');
            }
            (0, log_1.log)('generalDebug_0003', `Found app entry point in "${app}".`);
            return (0, path_1.join)((0, path_1.dirname)(packageName), app);
        }
        (0, log_1.log)('generalDebug_0003', `Found app entry point in "${rootDir}".`);
        return rootDir;
    });
}
exports.retrievePiralRoot = retrievePiralRoot;
function checkArrayOrUndefined(obj, key) {
    const items = obj[key];
    if (Array.isArray(items)) {
        return items;
    }
    else if (items !== undefined) {
        (0, log_1.log)('expectedArray_0072', key, typeof items);
    }
    return undefined;
}
function findDependencyVersion(pckg, rootPath, packageName) {
    var _a;
    const { devDependencies = {}, dependencies = {} } = pckg;
    const desiredVersion = (_a = dependencies[packageName]) !== null && _a !== void 0 ? _a : devDependencies[packageName];
    if (desiredVersion) {
        if ((0, npm_1.isGitPackage)(desiredVersion)) {
            return Promise.resolve((0, npm_1.makeGitUrl)(desiredVersion));
        }
        else if ((0, npm_1.isLocalPackage)(rootPath, desiredVersion)) {
            return Promise.resolve((0, npm_1.makeFilePath)(rootPath, desiredVersion));
        }
    }
    return findPackageVersion(rootPath, packageName);
}
exports.findDependencyVersion = findDependencyVersion;
function findPackageVersion(rootPath, packageName) {
    return __awaiter(this, void 0, void 0, function* () {
        try {
            (0, log_1.log)('generalDebug_0003', `Finding the version of "${packageName}" in "${rootPath}".`);
            const moduleName = require.resolve(packageName, {
                paths: [rootPath],
            });
            const packageJson = yield (0, io_2.findFile)(moduleName, 'package.json');
            return require(packageJson).version;
        }
        catch (e) {
            (0, log_1.log)('cannotResolveDependency_0053', packageName, rootPath);
            return 'latest';
        }
    });
}
exports.findPackageVersion = findPackageVersion;
function retrievePiletsInfo(entryFile) {
    return __awaiter(this, void 0, void 0, function* () {
        const exists = yield (0, io_2.checkExists)(entryFile);
        if (!exists) {
            (0, log_1.fail)('entryPointDoesNotExist_0073', entryFile);
        }
        const packageJson = yield (0, io_2.findFile)(entryFile, 'package.json');
        if (!packageJson) {
            (0, log_1.fail)('packageJsonMissing_0074');
        }
        const root = (0, path_1.dirname)(packageJson);
        const packageInfo = require(packageJson);
        const allDeps = Object.assign(Object.assign({}, packageInfo.devDependencies), packageInfo.dependencies);
        const info = getPiletsInfo(packageInfo);
        const externals = (0, npm_1.makeExternals)(root, allDeps, info.externals);
        return Object.assign(Object.assign({}, info), { externals, name: packageInfo.name, version: packageInfo.version, dependencies: {
                std: packageInfo.dependencies || {},
                dev: packageInfo.devDependencies || {},
                peer: packageInfo.peerDependencies || {},
            }, scripts: packageInfo.scripts, ignored: checkArrayOrUndefined(packageInfo, 'preservedDependencies'), root });
    });
}
exports.retrievePiletsInfo = retrievePiletsInfo;
function isValidDependency(name) {
    // super simple check at the moment
    // just to filter out things like "redux-saga/effects" and "@scope/redux-saga/effects"
    return name.indexOf('/') === -1 || (name.indexOf('@') === 0 && name.split('/').length < 3);
}
exports.isValidDependency = isValidDependency;
function patchPiletPackage(root, name, version, piralInfo, fromEmulator, newInfo) {
    return __awaiter(this, void 0, void 0, function* () {
        (0, log_1.log)('generalDebug_0003', `Patching the package.json in "${root}" ...`);
        const _a = getPiletsInfo(piralInfo), { externals, packageOverrides } = _a, info = __rest(_a, ["externals", "packageOverrides"]);
        const piral = {
            comment: 'Keep this section to use the Piral CLI.',
            name,
        };
        const piralDependencies = Object.assign(Object.assign({}, piralInfo.devDependencies), piralInfo.dependencies);
        const typeDependencies = newInfo ? (0, language_1.getDevDependencies)(newInfo.language) : {};
        const scripts = newInfo
            ? Object.assign({ start: 'pilet debug', build: 'pilet build', upgrade: 'pilet upgrade' }, info.scripts) : info.scripts;
        const peerModules = [];
        const allExternals = (0, npm_1.makePiletExternals)(root, piralDependencies, externals, fromEmulator, piralInfo);
        const peerDependencies = Object.assign(Object.assign({}, allExternals.reduce((deps, name) => {
            const valid = isValidDependency(name);
            deps[name] = valid ? '*' : undefined;
            if (!valid) {
                peerModules.push(name);
            }
            return deps;
        }, {})), { [name]: `*` });
        const devDependencies = Object.assign(Object.assign(Object.assign(Object.assign({}, Object.keys(typeDependencies).reduce((deps, name) => {
            deps[name] = piralDependencies[name] || typeDependencies[name];
            return deps;
        }, {})), Object.keys(info.devDependencies).reduce((deps, name) => {
            deps[name] = getDependencyVersion(name, info.devDependencies, piralDependencies);
            return deps;
        }, {})), allExternals.filter(isValidDependency).reduce((deps, name) => {
            const version = piralDependencies[name] || tryFindPackageVersion(name);
            if (version || newInfo) {
                // set only if we have an explicit version or we are in the scaffolding case
                deps[name] = version || 'latest';
            }
            return deps;
        }, {})), { [name]: `${version || piralInfo.version}` });
        if (newInfo) {
            const bundler = newInfo.bundler;
            const version = `^${info_1.cliVersion}`;
            devDependencies['piral-cli'] = version;
            appendBundler(devDependencies, bundler, version);
        }
        const packageContent = (0, merge_1.deepMerge)(packageOverrides, {
            piral,
            devDependencies,
            peerDependencies,
            peerModules,
            dependencies: {
                [name]: undefined,
            },
            scripts,
        });
        yield (0, io_2.updateExistingJson)(root, 'package.json', packageContent);
        (0, log_1.log)('generalDebug_0003', `Succesfully patched the package.json.`);
    });
}
exports.patchPiletPackage = patchPiletPackage;
/**
 * Returns true if its an emulator package, otherwise it has to be a "raw" app shell.
 */
function checkAppShellPackage(appPackage) {
    const { piralCLI = { generated: false, version: info_1.cliVersion } } = appPackage;
    if (piralCLI.generated) {
        (0, compatibility_1.checkAppShellCompatibility)(piralCLI.version);
        return true;
    }
    (0, log_1.log)('generalDebug_0003', `Missing "piralCLI" section. Assume raw app shell.`);
    return false;
}
exports.checkAppShellPackage = checkAppShellPackage;
function tryResolve(baseDir, name) {
    try {
        return require.resolve(name, {
            paths: [baseDir],
        });
    }
    catch (ex) {
        (0, log_1.log)('generalDebug_0003', `Could not resolve the package "${name}" in "${baseDir}": ${ex}`);
        return undefined;
    }
}
function normalizeDepName(s) {
    return (s.startsWith('@') ? s.substring(1) : s).replace(/[\/\.]/g, '-').replace(/(\-)+/, '-');
}
function resolveImportmap(dir, importmap) {
    return __awaiter(this, void 0, void 0, function* () {
        const dependencies = [];
        const sharedImports = importmap === null || importmap === void 0 ? void 0 : importmap.imports;
        if (typeof sharedImports === 'object' && sharedImports) {
            for (const depName of Object.keys(sharedImports)) {
                const url = sharedImports[depName];
                const assetName = normalizeDepName(depName);
                if (typeof url !== 'string') {
                }
                else if (/^https?:\/\//.test(url)) {
                    const hash = (0, hash_1.computeHash)(url).substring(0, 7);
                    dependencies.push({
                        id: `${depName}@${hash}`,
                        entry: url,
                        name: depName,
                        ref: url,
                        type: 'remote',
                    });
                }
                else if (url === depName) {
                    const entry = tryResolve(dir, depName);
                    if (entry) {
                        const packageJson = yield (0, io_2.findFile)((0, path_1.dirname)(entry), 'package.json');
                        const details = require(packageJson);
                        dependencies.push({
                            id: `${depName}@${details.version}`,
                            entry,
                            ref: `${assetName}.js`,
                            name: depName,
                            type: 'local',
                        });
                    }
                }
                else {
                    const entry = (0, path_1.resolve)(dir, url);
                    const exists = yield (0, io_2.checkExists)(entry);
                    if (exists) {
                        const packageJson = yield (0, io_2.findFile)((0, path_1.dirname)(entry), 'package.json');
                        if (packageJson) {
                            const details = require(packageJson);
                            dependencies.push({
                                id: `${depName}@${details.version}`,
                                entry,
                                name: depName,
                                ref: `${assetName}.js`,
                                type: 'local',
                            });
                        }
                        else {
                            const hash = yield (0, io_1.getHash)(entry);
                            dependencies.push({
                                id: `${depName}@${hash}`,
                                entry,
                                name: depName,
                                ref: `${assetName}.js`,
                                type: 'local',
                            });
                        }
                    }
                }
            }
        }
        return dependencies;
    });
}
function readImportmap(dir, packageDetails) {
    return __awaiter(this, void 0, void 0, function* () {
        const importmap = packageDetails.importmap;
        if (typeof importmap === 'string') {
            const content = yield (0, io_2.readJson)(dir, importmap);
            const baseDir = (0, path_1.dirname)((0, path_1.resolve)(dir, importmap));
            return resolveImportmap(baseDir, content);
        }
        return resolveImportmap(dir, importmap);
    });
}
exports.readImportmap = readImportmap;
function retrievePiletData(target, app) {
    return __awaiter(this, void 0, void 0, function* () {
        const packageJson = yield (0, io_2.findFile)(target, 'package.json');
        if (!packageJson) {
            (0, log_1.fail)('packageJsonMissing_0075');
        }
        const root = (0, path_1.dirname)(packageJson);
        const piletPackage = require(packageJson);
        const appPackage = findPackage(app || (piletPackage.piral && piletPackage.piral.name) || Object.keys(piletPackage.devDependencies), target);
        const appFile = appPackage && appPackage.app;
        if (!appFile) {
            (0, log_1.fail)('appInstanceInvalid_0011');
        }
        const emulator = checkAppShellPackage(appPackage);
        const importmap = yield readImportmap(root, piletPackage);
        return {
            dependencies: piletPackage.dependencies || {},
            devDependencies: piletPackage.devDependencies || {},
            peerDependencies: piletPackage.peerDependencies || {},
            peerModules: piletPackage.peerModules || [],
            ignored: checkArrayOrUndefined(piletPackage, 'preservedDependencies'),
            importmap,
            appFile,
            piletPackage,
            appPackage,
            emulator,
            root,
        };
    });
}
exports.retrievePiletData = retrievePiletData;
//# sourceMappingURL=package.js.map