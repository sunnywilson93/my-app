"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.upgradePiral = exports.upgradePiralDefaults = void 0;
const path_1 = require("path");
const types_1 = require("../types");
const common_1 = require("../common");
exports.upgradePiralDefaults = {
    version: 'latest',
    target: '.',
    logLevel: types_1.LogLevels.info,
    install: true,
    npmClient: undefined,
};
function updateDependencies(deps, version) {
    var _a;
    if (deps) {
        for (const name of Object.keys(deps)) {
            try {
                const data = require(`${name}/package.json`);
                const packageRepoUrl = (_a = data === null || data === void 0 ? void 0 : data.repository) === null || _a === void 0 ? void 0 : _a.url;
                if (packageRepoUrl === common_1.repositoryUrl) {
                    deps[name] = version;
                }
            }
            catch (_b) {
                (0, common_1.log)('packageNotInstalled_0023', name);
            }
        }
    }
}
function upgradePiral(baseDir = process.cwd(), options = {}) {
    return __awaiter(this, void 0, void 0, function* () {
        const { version = exports.upgradePiralDefaults.version, target = exports.upgradePiralDefaults.target, logLevel = exports.upgradePiralDefaults.logLevel, install = exports.upgradePiralDefaults.install, } = options;
        const fullBase = (0, path_1.resolve)(process.cwd(), baseDir);
        const root = (0, path_1.resolve)(fullBase, target);
        (0, common_1.setLogLevel)(logLevel);
        const valid = yield (0, common_1.checkExistingDirectory)(root);
        const exists = yield (0, common_1.checkExists)((0, path_1.join)(root, 'package.json'));
        if (!valid || !exists) {
            (0, common_1.fail)('packageJsonNotFound_0020');
        }
        const npmClient = yield (0, common_1.determineNpmClient)(root, options.npmClient);
        (0, common_1.progress)(`Checking provided version ...`);
        const realVersion = yield (0, common_1.findSpecificVersion)('piral-cli', version);
        if (!realVersion) {
            (0, common_1.fail)('packageVersionInvalid_0024', version);
        }
        (0, common_1.log)('generalDebug_0003', `Found real version: "${version}".`);
        const pckg = yield (0, common_1.readJson)(root, 'package.json');
        (0, common_1.log)('generalDebug_0003', `Updating all dependencies ...`);
        (0, common_1.progress)(`Reading installed packages ...`);
        updateDependencies(pckg.devDependencies, realVersion);
        updateDependencies(pckg.dependencies, realVersion);
        (0, common_1.log)('generalDebug_0003', `Patching the package.json ...`);
        yield (0, common_1.updateExistingJson)(root, 'package.json', pckg);
        if (install) {
            (0, common_1.progress)(`Updating the npm packages to %s ...`, version);
            yield (0, common_1.installNpmDependencies)(npmClient, root);
        }
        (0, common_1.logDone)('Piral instance upgraded successfully!');
    });
}
exports.upgradePiral = upgradePiral;
//# sourceMappingURL=upgrade-piral.js.map