"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.runQuestionnaire = exports.runQuestionnaireFor = void 0;
const external_1 = require("./external");
const commands_1 = require("./commands");
function getCommandData(retrieve) {
    const instructions = [];
    const fn = {
        positional(name, info) {
            instructions.push(Object.assign(Object.assign({}, info), { name }));
            return this;
        },
        swap(name, swapper) {
            const [flag] = instructions.filter((m) => m.name === name);
            const newFlag = swapper(flag || { name });
            if (!flag) {
                instructions.push(newFlag);
            }
            else {
                Object.assign(flag, newFlag);
            }
            return this;
        },
        option(name) {
            return this.swap(name, (flag) => (Object.assign(Object.assign({}, flag), { value: {}, type: 'object' })));
        },
        choices(name, choices) {
            return this.swap(name, (flag) => (Object.assign(Object.assign({}, flag), { type: 'string', values: choices })));
        },
        string(name) {
            return this.swap(name, (flag) => (Object.assign(Object.assign({}, flag), { type: 'string' })));
        },
        boolean(name) {
            return this.swap(name, (flag) => (Object.assign(Object.assign({}, flag), { type: 'boolean' })));
        },
        describe(name, value) {
            return this.swap(name, (flag) => (Object.assign(Object.assign({}, flag), { describe: value })));
        },
        default(name, value) {
            return this.swap(name, (flag) => (Object.assign(Object.assign({}, flag), { default: value })));
        },
        number(name) {
            return this.swap(name, (flag) => (Object.assign(Object.assign({}, flag), { type: 'number' })));
        },
        demandOption(name) {
            return this.swap(name, (flag) => (Object.assign(Object.assign({}, flag), { required: true })));
        },
    };
    if (typeof retrieve === 'function') {
        retrieve(fn);
    }
    return instructions;
}
function getValue(type, value) {
    switch (type) {
        case 'boolean':
            return !!value;
        case 'number':
            return +value;
        case 'string':
            return value;
        case 'object':
            return value;
    }
}
function getType(flag) {
    switch (flag.type) {
        case 'string':
            if (flag.values) {
                return 'list';
            }
            return 'input';
        case 'number':
            return 'input';
        case 'boolean':
            return 'confirm';
    }
}
function runQuestionnaireFor(command, args, ignoredInstructions = ['base', 'log-level']) {
    const acceptAll = args.y === true || args.defaults === true;
    const instructions = getCommandData(command.flags);
    const ignored = Array.isArray(ignoredInstructions) ? ignoredInstructions : Object.keys(ignoredInstructions);
    const questions = instructions
        .filter((instruction) => !ignored.includes(instruction.name))
        .filter((instruction) => !acceptAll || (instruction.default === undefined && instruction.required))
        .filter((instruction) => args[instruction.name] === undefined)
        .filter((instruction) => instruction.type !== 'object')
        .map((instruction) => ({
        name: instruction.name,
        default: instruction.values ? instruction.values.indexOf(instruction.default) : instruction.default,
        message: instruction.describe,
        type: getType(instruction),
        choices: instruction.values,
        validate: instruction.type === 'number' ? (input) => !isNaN(+input) : () => true,
    }));
    return external_1.inquirer.prompt(questions).then((answers) => {
        var _a, _b;
        const parameters = {};
        for (const instruction of instructions) {
            const name = instruction.name;
            const value = (_b = (_a = answers[name]) !== null && _a !== void 0 ? _a : ignoredInstructions[name]) !== null && _b !== void 0 ? _b : args[name];
            parameters[name] = value !== undefined ? getValue(instruction.type, value) : instruction.default;
        }
        return command.run(parameters);
    });
}
exports.runQuestionnaireFor = runQuestionnaireFor;
function runQuestionnaire(commandName, ignoredInstructions = ['base', 'log-level']) {
    const { argv } = require('yargs');
    const [command] = commands_1.commands.all.filter((m) => m.name === commandName);
    return runQuestionnaireFor(command, argv, ignoredInstructions);
}
exports.runQuestionnaire = runQuestionnaire;
//# sourceMappingURL=questionnaire.js.map