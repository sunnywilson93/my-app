"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createDeferredStrategy = exports.syncStrategy = exports.standardStrategy = exports.asyncStrategy = exports.blazingStrategy = exports.createProgressiveStrategy = void 0;
const loader_1 = require("./loader");
const load_1 = require("./load");
const system_1 = require("./system");
const aggregate_1 = require("./aggregate");
function evalAll(createApi, oldModules, newModules) {
    if (!Array.isArray(oldModules)) {
        return Promise.reject(`The existing pilets must be passed as an array.`);
    }
    try {
        for (const oldModule of oldModules) {
            const [newModule] = newModules.filter((m) => m.name === oldModule.name);
            if (newModule) {
                newModules.splice(newModules.indexOf(newModule), 1);
            }
        }
        return (0, aggregate_1.createPilets)(createApi, [...oldModules, ...newModules]);
    }
    catch (err) {
        return Promise.reject(err);
    }
}
/**
 * This strategy is dependent on the async parameter. If false it will start rendering when
 * everything has been received, otherwise it will start rendering when the metadata has been
 * received. In any case it will evaluate pilets as fast as possible.
 * @param async Uses the asynchronous mode.
 */
function createProgressiveStrategy(async) {
    return (options, cb) => {
        const { fetchPilets, dependencies = {}, createApi, config, pilets = [], loadPilet = (0, loader_1.getDefaultLoader)(config), loaders, } = options;
        const loader = (0, load_1.loadMetadata)(fetchPilets);
        const loadSingle = (0, loader_1.extendLoader)(loadPilet, loaders);
        return (0, system_1.registerDependencies)(dependencies).then(() => (0, aggregate_1.createPilets)(createApi, pilets).then((allModules) => {
            if (async && allModules.length > 0) {
                cb(undefined, [...allModules]);
            }
            const followUp = loader.then((metadata) => {
                const promises = metadata.map((m) => loadSingle(m).then((mod) => {
                    const available = pilets.filter((m) => m.name === mod.name).length === 0;
                    if (available) {
                        return (0, aggregate_1.createPilet)(createApi, mod).then((newModule) => {
                            allModules.push(newModule);
                            if (async) {
                                cb(undefined, [...allModules]);
                            }
                        });
                    }
                }));
                return Promise.all(promises).then(() => {
                    if (!async) {
                        cb(undefined, allModules);
                    }
                });
            });
            return async ? loader.then() : followUp.then();
        }));
    };
}
exports.createProgressiveStrategy = createProgressiveStrategy;
/**
 * This strategy starts rendering when the pilets metadata has been received.
 * Evaluates the pilets once available without waiting for all pilets to be
 * available.
 */
function blazingStrategy(options, cb) {
    const strategy = createProgressiveStrategy(true);
    return strategy(options, cb);
}
exports.blazingStrategy = blazingStrategy;
/**
 * The async strategy picked when no strategy is declared and async is set to
 * true. Directly renders, but waits for all pilets to be available before
 * evaluating them.
 */
function asyncStrategy(options, cb) {
    standardStrategy(options, cb);
    return Promise.resolve();
}
exports.asyncStrategy = asyncStrategy;
/**
 * The standard strategy that is used if no strategy is declared and async is
 * false. Loads and evaluates all pilets before rendering.
 */
function standardStrategy(options, cb) {
    const { fetchPilets, dependencies = {}, createApi, config, pilets = [], loadPilet = (0, loader_1.getDefaultLoader)(config), loaders, } = options;
    const loadSingle = (0, loader_1.extendLoader)(loadPilet, loaders);
    return (0, system_1.registerDependencies)(dependencies)
        .then(() => (0, load_1.loadPilets)(fetchPilets, loadSingle))
        .then((newModules) => evalAll(createApi, pilets, newModules))
        .then((modules) => cb(undefined, modules))
        .catch((error) => cb(error, []));
}
exports.standardStrategy = standardStrategy;
/**
 * The strategy that could be used for special purposes, e.g., SSR or specific
 * builds of the Piral instance. This strategy ignores the fetcher and only
 * considers the already given pilets.
 */
function syncStrategy(options, cb) {
    const { createApi, dependencies = {}, pilets = [] } = options;
    return (0, system_1.registerDependencies)(dependencies).then(() => evalAll(createApi, pilets, []).then((modules) => cb(undefined, modules), (err) => cb(err, [])));
}
exports.syncStrategy = syncStrategy;
/**
 * Creates a strategy that deferres the actual loading until a trigger promise resolves.
 * The loading spinner is not shown during this time and pilets are supposed to appear directly.
 * @param trigger The trigger resolving when the strategy should be applied.
 * @param strategy The strategy to apply. Falls back to the standard strategy.
 * @returns A pilet loading strategy.
 */
function createDeferredStrategy(trigger, strategy = standardStrategy) {
    return (options, cb) => {
        cb(undefined, []);
        trigger.then(() => strategy(options, cb));
        return Promise.resolve();
    };
}
exports.createDeferredStrategy = createDeferredStrategy;
//# sourceMappingURL=strategies.js.map