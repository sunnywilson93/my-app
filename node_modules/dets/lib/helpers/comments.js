"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getComment = exports.getCommentOrDrop = exports.stringifyJsDocs = exports.getJsDocs = exports.getAllJsDocs = void 0;
const typescript_1 = require("typescript");
function isUnique(value, index, self) {
    return self.indexOf(value) === index;
}
function getAllJsDocs(checker, decls) {
    const allDocs = decls.map((decl) => getJsDocs(checker, decl));
    return {
        comment: allDocs
            .map((m) => m.comment)
            .reduce((p, c) => [...p, ...c], [])
            .filter(isUnique),
        tags: allDocs
            .map((m) => m.tags)
            .reduce((p, c) => [...p, ...c], [])
            .filter(isUnique),
    };
}
exports.getAllJsDocs = getAllJsDocs;
function getJsDocs(checker, node) {
    var _a, _b;
    if (typescript_1.isMethodDeclaration(node) || typescript_1.isMethodSignature(node)) {
        const sign = checker.getSignatureFromDeclaration(node);
        if (sign) {
            return {
                comment: sign.getDocumentationComment(checker),
                tags: sign.getJsDocTags(),
            };
        }
    }
    return {
        comment: (_a = node.symbol) === null || _a === void 0 ? void 0 : _a.getDocumentationComment(checker),
        tags: (_b = node.symbol) === null || _b === void 0 ? void 0 : _b.getJsDocTags(),
    };
}
exports.getJsDocs = getJsDocs;
const newLineTags = ['example'];
const removedTags = ['dets_removeprop', 'dets_removeclause', 'dets_preserve', 'dets_ignore'];
function stringifyJsDocTagText(txt) {
    if (typeof txt === 'string') {
        // quick fix for URLs (e.g., in React documentation), just remove first space
        if (txt.startsWith('http ://') || txt.startsWith('https ://')) {
            return txt.replace(' ', '');
        }
        return txt;
    }
    else if (Array.isArray(txt)) {
        return txt.map((s) => s.text).join('');
    }
    return '';
}
function stringifyJsDocs(doc) {
    const tags = (doc.tags || [])
        .filter((m) => !removedTags.includes(m.name))
        .map((m) => `@${m.name}${newLineTags.includes(m.name) ? '\n' : m.text ? ' ' : ''}${stringifyJsDocTagText(m.text)}`);
    const result = doc.comment ? doc.comment.map((m) => m.text) : [];
    if (tags) {
        result.push(...tags);
    }
    return result.join('\n');
}
exports.stringifyJsDocs = stringifyJsDocs;
function shouldDrop(canDrop, tags) {
    let found = false;
    if (tags) {
        for (const tag of tags) {
            switch (tag.name) {
                case 'ignore':
                    found = canDrop;
                    break;
                case 'dets_ignore':
                    return true;
                case 'dets_preserve':
                    return false;
            }
        }
    }
    return found;
}
function getCommentOrDrop(checker, node, canDrop = false) {
    const doc = getJsDocs(checker, node);
    if (shouldDrop(canDrop, doc.tags)) {
        return undefined;
    }
    return stringifyJsDocs(doc);
}
exports.getCommentOrDrop = getCommentOrDrop;
function getComment(checker, node) {
    const doc = getJsDocs(checker, node);
    return stringifyJsDocs(doc);
}
exports.getComment = getComment;
