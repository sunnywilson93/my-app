"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.DeclVisitor = void 0;
const ts = require("typescript");
const utils_1 = require("./utils");
const includes_1 = require("./includes");
const helpers_1 = require("../helpers");
class DeclVisitor {
    constructor(context) {
        var _a, _b, _c;
        this.context = context;
        this.queue = [];
        this.modules = [];
        this.processed = [];
        const [defaultModule] = Object.keys((_a = context.modules) !== null && _a !== void 0 ? _a : {});
        this.refs = (_b = context.modules[defaultModule]) !== null && _b !== void 0 ? _b : [];
        this.names = (_c = context.moduleNames[defaultModule]) !== null && _c !== void 0 ? _c : new Map();
        for (const node of context.exports) {
            this.enqueue(node);
        }
    }
    logVerbose(message) {
        this.context.log.verbose(message);
    }
    logWarn(message) {
        this.context.log.warn(message);
    }
    printWarning(type, node) {
        var _a;
        this.logWarn(`Could not resolve ${type} at position ${node.pos} of "${(_a = node.getSourceFile()) === null || _a === void 0 ? void 0 : _a.fileName}". Kind: ${node.kind}.`);
    }
    swapName(oldName, newName) {
        const refs = this.refs;
        const last = refs.pop();
        if (!last) {
            // empty on purpose
        }
        else if (last.kind === 'default') {
            if (last.value.kind === 'ref') {
                const name = last.value.refName;
                for (let i = refs.length; i--;) {
                    const ref = refs[i];
                    if (ref.name === name) {
                        refs.splice(i, 1, Object.assign(Object.assign({}, ref), { name: newName }));
                        break;
                    }
                }
            }
        }
        else if ('name' in last && last.name === oldName) {
            refs.push(Object.assign(Object.assign({}, last), { name: newName }));
        }
        else {
            refs.push(last);
        }
    }
    findName(node) {
        return this.names.get(node);
    }
    createName(name) {
        const altStart = `${name}___`;
        const available = new Set();
        for (const m of this.names.values()) {
            if (m === name || m.startsWith(altStart)) {
                available.add(m);
            }
        }
        const count = available.size;
        if (count) {
            return `${altStart}${count}`;
        }
        return name;
    }
    getName(node, suggested) {
        var _a, _b;
        const existing = this.findName(node);
        if (!existing) {
            this.logVerbose(`Missing "name". Retrieving with suggestion "${suggested}".`);
            const name = this.createName(suggested);
            const decls = (_b = (_a = node.symbol) === null || _a === void 0 ? void 0 : _a.declarations) !== null && _b !== void 0 ? _b : [node];
            decls.forEach((decl) => this.names.set(decl, name));
            return name;
        }
        return existing;
    }
    normalizeName(node) {
        var _a, _b;
        const c = this.context;
        const symbol = (_b = (_a = node.symbol) !== null && _a !== void 0 ? _a : node.aliasSymbol) !== null && _b !== void 0 ? _b : c.checker.getSymbolAtLocation(node);
        const global = helpers_1.isGlobal(symbol);
        const { moduleName, lib, symbolName } = utils_1.getPackage(node, global, c.root, c.availableImports);
        if (!lib) {
            const name = global ? helpers_1.fullyQualifiedName(symbol, '_') : helpers_1.getSymbolName(symbol);
            return this.getName(node, name);
        }
        else if (global) {
            return helpers_1.fullyQualifiedName(symbol, '.');
        }
        else {
            return utils_1.createBinding(c, moduleName, symbolName !== null && symbolName !== void 0 ? symbolName : helpers_1.getSymbolName(symbol));
        }
    }
    convertToTypeNodeFromType(type) {
        const c = this.context.checker;
        return c.typeToTypeNode(type, undefined, ts.NodeBuilderFlags.NoTruncation);
    }
    convertToTypeNodeFromNode(node) {
        const type = this.context.checker.getTypeAtLocation(node);
        return this.convertToTypeNodeFromType(type);
    }
    valueFromLiteral(node) {
        var _a;
        switch (node.literal.kind) {
            case ts.SyntaxKind.StringLiteral:
                return JSON.stringify(node.literal.text);
            case ts.SyntaxKind.TrueKeyword:
                return 'true';
            case ts.SyntaxKind.FalseKeyword:
                return 'false';
            case ts.SyntaxKind.NumericLiteral:
            case ts.SyntaxKind.BigIntLiteral:
                return node.literal.text;
            default:
                this.logVerbose(`No match for literal node kind "${node.literal.kind}". Trying to get from type node...`);
                const type = this.context.checker.getTypeFromTypeNode(node);
                return (_a = type === null || type === void 0 ? void 0 : type.intrinsicName) !== null && _a !== void 0 ? _a : type === null || type === void 0 ? void 0 : type.value;
        }
    }
    getInferredType(node) {
        const typeNode = this.convertToTypeNodeFromNode(node);
        return this.getTypeNode(typeNode);
    }
    getUnion(node) {
        return {
            kind: 'union',
            types: node.types.map((m) => this.getNode(m)),
        };
    }
    getLiteral(node) {
        return {
            kind: 'literal',
            value: this.valueFromLiteral(node),
        };
    }
    getNode(node) {
        if (ts.isTypeNode(node)) {
            return this.getTypeNode(node);
        }
        else if (ts.isTypeAliasDeclaration(node) ||
            ts.isFunctionDeclaration(node) ||
            ts.isInterfaceDeclaration(node) ||
            ts.isClassDeclaration(node)) {
            this.enqueue(node);
            return utils_1.getRef(this.normalizeName(node), this.getTypeParameters(node.typeParameters));
        }
        else if (helpers_1.isDefaultExport(node) || ts.isVariableDeclaration(node) || ts.isVariableStatement(node)) {
            this.enqueue(node);
            return utils_1.getRef(this.normalizeName(node));
        }
        else if (ts.isPropertyAssignment(node)) {
            return {
                kind: 'prop',
                modifiers: helpers_1.getModifiers(node.symbol),
                name: node.symbol.name,
                optional: node.questionToken !== undefined,
                valueType: this.getExpression(node.initializer),
            };
        }
        this.logVerbose(`Node is presumably a reference. Found kind "${node.kind}".`);
        return utils_1.getRef(node.symbol.name);
    }
    getPropDeclaration(node) {
        var _a;
        const type = (_a = node.type) !== null && _a !== void 0 ? _a : this.convertToTypeNodeFromNode(node);
        return this.getTypeNode(type);
    }
    getPropValue(node) {
        if (ts.isPropertySignature(node)) {
            return this.getTypeNode(node.type);
        }
        else if (ts.isMethodSignature(node)) {
            return this.getMethodSignature(node);
        }
        else if (ts.isPropertyDeclaration(node)) {
            return this.getPropDeclaration(node);
        }
        else if (ts.isMethodDeclaration(node)) {
            return this.getMethodSignature(node);
        }
        this.printWarning('property', node);
    }
    getNormalProp(node) {
        var _a, _b;
        const { checker, flags } = this.context;
        const canDrop = !flags.noIgnore;
        const comment = helpers_1.getCommentOrDrop(checker, (_b = (_a = node.emitNode) === null || _a === void 0 ? void 0 : _a.commentRange) !== null && _b !== void 0 ? _b : node, canDrop);
        if (typeof comment === 'string') {
            return {
                kind: 'prop',
                name: helpers_1.getPropName(node.name),
                modifiers: helpers_1.getModifiers(node.symbol),
                optional: node.questionToken !== undefined,
                comment,
                valueType: this.getPropValue(node),
            };
        }
        this.logVerbose(`The prop "${helpers_1.getPropName(node.name)}" was skipped due to @ignore.`);
        return undefined;
    }
    getIndexProp(node) {
        return {
            kind: 'index',
            parameters: this.getFunctionParameters(node.parameters),
            optional: node.questionToken !== undefined,
            valueType: this.getTypeNode(node.type),
        };
    }
    getConstructor(node) {
        return {
            kind: 'constructor',
            parameters: this.getFunctionParameters(node.parameters),
            comment: helpers_1.getComment(this.context.checker, node),
        };
    }
    getClassMember(node) {
        const { checker, flags } = this.context;
        const canDrop = !flags.noIgnore;
        const comment = helpers_1.getCommentOrDrop(checker, node, canDrop);
        if (typeof comment === 'string') {
            return {
                kind: 'prop',
                name: node.name.getText(),
                modifiers: helpers_1.getModifiers(node.symbol),
                optional: false,
                comment,
                valueType: this.getPropValue(node),
            };
        }
        this.logVerbose(`The member "${node.name.getText()}" was skipped due to @ignore.`);
        return undefined;
    }
    getProps(nodes) {
        const props = [];
        nodes === null || nodes === void 0 ? void 0 : nodes.forEach((node) => {
            if (ts.isIndexSignatureDeclaration(node)) {
                props.push(this.getIndexProp(node));
            }
            else if (ts.isCallSignatureDeclaration(node)) {
                props.push(this.getMethodSignature(node));
            }
            else if (ts.isConstructSignatureDeclaration(node)) {
                props.push(this.getConstructorCall(node));
            }
            else if (ts.isGetAccessor(node)) {
                const prop = this.getGetAccessor(node);
                prop && props.push(prop);
            }
            else if (ts.isSetAccessor(node)) {
                const prop = this.getSetAccessor(node);
                prop && props.push(prop);
            }
            else {
                this.logVerbose(`Getting props - assuming node of kind "${node === null || node === void 0 ? void 0 : node.kind}" is a normal prop.`);
                const prop = this.getNormalProp(node);
                prop && props.push(prop);
            }
        });
        return props;
    }
    getClassMembers(nodes) {
        const members = [];
        nodes === null || nodes === void 0 ? void 0 : nodes.forEach((node) => {
            if (ts.isConstructorDeclaration(node)) {
                members.push(this.getConstructor(node));
            }
            else if (ts.isCallSignatureDeclaration(node)) {
                members.push(this.getMethodSignature(node));
            }
            else if (ts.isConstructSignatureDeclaration(node)) {
                members.push(this.getConstructorCall(node));
            }
            else if (ts.isGetAccessor(node)) {
                const member = this.getGetAccessor(node);
                member && members.push(member);
            }
            else if (ts.isSetAccessor(node)) {
                const member = this.getSetAccessor(node);
                member && members.push(member);
            }
            else if (ts.isIndexSignatureDeclaration(node)) {
                members.push(this.getIndexProp(node));
            }
            else {
                this.logVerbose(`Getting class members - assuming node of kind "${node === null || node === void 0 ? void 0 : node.kind}" is a class member.`);
                const member = this.getClassMember(node);
                member && members.push(member);
            }
        });
        return members;
    }
    getEnumMember(node) {
        const value = node.initializer;
        return {
            kind: 'member',
            name: helpers_1.getPropName(node.name),
            value: value && this.getExpression(value),
            comment: helpers_1.getComment(this.context.checker, node),
        };
    }
    getEnumMembers(nodes) {
        var _a;
        return (_a = nodes === null || nodes === void 0 ? void 0 : nodes.map((node) => this.getEnumMember(node))) !== null && _a !== void 0 ? _a : [];
    }
    getReturnType(node) {
        var _a;
        const checker = this.context.checker;
        const type = (_a = node.type) !== null && _a !== void 0 ? _a : this.convertToTypeNodeFromType(checker.getReturnTypeOfSignature(checker.getSignatureFromDeclaration(node)));
        return this.getTypeNode(type);
    }
    getFunctionDeclaration(node) {
        const name = this.getName(node, node.name.text);
        return Object.assign(Object.assign({}, this.getMethodSignature(node)), { name });
    }
    getMethodSignature(node) {
        return {
            kind: 'function',
            name: undefined,
            parameters: this.getFunctionParameters(node.parameters),
            returnType: this.getReturnType(node),
            types: this.getTypeParameters(node.typeParameters),
            comment: helpers_1.getComment(this.context.checker, node),
        };
    }
    getConstructorCall(node) {
        return {
            kind: 'new',
            parameters: this.getFunctionParameters(node.parameters),
            returnType: this.getTypeNode(node.type),
            types: this.getTypeParameters(node.typeParameters),
            comment: helpers_1.getComment(this.context.checker, node),
        };
    }
    getTypeParameter(node) {
        return {
            kind: 'typeParameter',
            parameter: utils_1.getRef(node.name.text),
            constraint: node.constraint && this.getTypeNode(node.constraint),
            default: node.default && this.getTypeNode(node.default),
        };
    }
    getTypeParameters(nodes) {
        var _a;
        return (_a = nodes === null || nodes === void 0 ? void 0 : nodes.map((node) => this.getTypeParameter(node))) !== null && _a !== void 0 ? _a : [];
    }
    getTypeArguments(nodes) {
        var _a;
        return (_a = nodes === null || nodes === void 0 ? void 0 : nodes.map((node) => this.getTypeNode(node))) !== null && _a !== void 0 ? _a : [];
    }
    getFunctionParameterValue(node) {
        if (node.type) {
            return this.getTypeNode(node.type);
        }
        else if (node.initializer) {
            return this.getExpression(node.initializer);
        }
        else {
            this.logVerbose(`Found unidentified node of kind "${node.kind}" in function parameter value. Falling back to "any".`);
            return {
                kind: 'any',
            };
        }
    }
    getFunctionParameter(node) {
        return {
            kind: 'parameter',
            param: helpers_1.getParameterName(node.name),
            spread: node.dotDotDotToken !== undefined,
            optional: node.questionToken !== undefined || node.initializer !== undefined,
            modifiers: helpers_1.getModifiers(node.symbol),
            value: this.getFunctionParameterValue(node),
        };
    }
    getFunctionParameters(nodes) {
        var _a;
        return (_a = nodes === null || nodes === void 0 ? void 0 : nodes.map((node) => this.getFunctionParameter(node))) !== null && _a !== void 0 ? _a : [];
    }
    getIndexAccess(node) {
        return {
            kind: 'indexedAccess',
            index: this.getTypeNode(node.indexType),
            object: this.getTypeNode(node.objectType),
        };
    }
    getTypeOperator(node) {
        switch (node.operator) {
            case ts.SyntaxKind.KeyOfKeyword:
                return {
                    kind: 'keyof',
                    value: this.getTypeNode(node.type),
                };
            case ts.SyntaxKind.UniqueKeyword:
                return {
                    kind: 'unique',
                    value: this.getTypeNode(node.type),
                };
            case ts.SyntaxKind.ReadonlyKeyword:
                return {
                    kind: 'readonly',
                    value: this.getTypeNode(node.type),
                };
            default:
                this.logWarn(`Found unknown type operator node of kind "${node.kind}".`);
        }
    }
    getMappedType(node) {
        const p = node.typeParameter;
        return {
            kind: 'interface',
            name: undefined,
            extends: [],
            props: [],
            types: [],
            comment: helpers_1.getComment(this.context.checker, node),
            mapped: {
                kind: 'mapped',
                constraint: this.getTypeNode(p.constraint),
                name: p.name.text,
                optional: node.questionToken !== undefined,
                value: this.getTypeNode(node.type),
            },
        };
    }
    getConditionalType(node) {
        return {
            kind: 'conditional',
            alternate: this.getTypeNode(node.falseType),
            check: this.getTypeNode(node.checkType),
            extends: this.getTypeNode(node.extendsType),
            primary: this.getTypeNode(node.trueType),
        };
    }
    getPredicate(node) {
        return {
            kind: 'predicate',
            name: helpers_1.getPredicateName(node.parameterName),
            value: this.getTypeNode(node.type),
        };
    }
    getSetAccessor(node) {
        const { checker, flags } = this.context;
        const canDrop = !flags.noIgnore;
        const comment = helpers_1.getCommentOrDrop(checker, node, canDrop);
        if (typeof comment === 'string') {
            return {
                kind: 'set',
                name: helpers_1.getPropName(node.name),
                parameters: this.getFunctionParameters(node.parameters),
                comment,
                modifiers: helpers_1.getModifiers(node.symbol),
            };
        }
        this.logVerbose(`The setter "${helpers_1.getPropName(node.name)}" was skipped due to @ignore.`);
        return undefined;
    }
    getGetAccessor(node) {
        const { checker, flags } = this.context;
        const canDrop = !flags.noIgnore;
        const comment = helpers_1.getCommentOrDrop(checker, node, canDrop);
        if (typeof comment === 'string') {
            return {
                kind: 'get',
                name: helpers_1.getPropName(node.name),
                type: this.getReturnType(node),
                comment,
                modifiers: helpers_1.getModifiers(node.symbol),
            };
        }
        this.logVerbose(`The getter "${helpers_1.getPropName(node.name)}" was skipped due to @ignore.`);
        return undefined;
    }
    getTypeReference(node) {
        const c = this.context.checker;
        const decl = helpers_1.getDeclarationFromNode(c, node);
        if (decl && !ts.isTypeParameterDeclaration(decl)) {
            this.enqueue(decl);
            return utils_1.getRef(this.normalizeName(decl), this.getTypeArguments(node.typeArguments));
        }
        return utils_1.getRef(helpers_1.getTypeRefName(node.typeName), this.getTypeArguments(node.typeArguments));
    }
    getTypeLiteral(node) {
        return {
            kind: 'interface',
            name: undefined,
            comment: helpers_1.getComment(this.context.checker, node),
            extends: [],
            props: this.getProps(node.members),
            types: [],
        };
    }
    getExpressionWithTypeArguments(node) {
        const decl = helpers_1.getDeclarationFromNode(this.context.checker, node.expression);
        this.enqueue(decl);
        return utils_1.getRef(this.normalizeName(decl), this.getTypeArguments(node.typeArguments));
    }
    getArray(node) {
        return utils_1.getRef('Array', [this.getTypeNode(node.elementType)]);
    }
    getInfer(node) {
        return {
            kind: 'infer',
            parameter: this.getTypeParameter(node.typeParameter),
        };
    }
    getIntersection(node) {
        return {
            kind: 'intersection',
            types: node.types.map((n) => this.getTypeNode(n)),
        };
    }
    getTuple(node) {
        var _a;
        return {
            kind: 'tuple',
            types: ((_a = node['elementTypes']) !== null && _a !== void 0 ? _a : node.elements).map((n) => this.getTypeNode(n)),
        };
    }
    getParenthesis(node) {
        return {
            kind: 'parenthesis',
            value: this.getTypeNode(node.type),
        };
    }
    getTypeQueryNode(node) {
        const symbol = this.context.checker.getSymbolAtLocation(node.exprName);
        if (symbol !== undefined) {
            const type = this.context.checker.getTypeOfSymbolAtLocation(symbol, node);
            const typeNode = this.convertToTypeNodeFromType(type);
            if (typeNode && ts.isImportTypeNode(typeNode)) {
                const props = type
                    .getProperties()
                    .map((prop) => ({
                    name: prop.name,
                    decl: prop.valueDeclaration,
                }))
                    .map((m) => ({
                    name: m.name,
                    type: m.decl && this.context.checker.getTypeOfSymbolAtLocation(m.decl.symbol, m.decl),
                }))
                    .map((m) => ({
                    name: m.name,
                    node: m.type && this.convertToTypeNodeFromType(m.type),
                }))
                    .map((m) => ({
                    name: m.name,
                    modifiers: '',
                    optional: false,
                    kind: 'prop',
                    valueType: this.getTypeNode(m.node),
                }));
                return {
                    kind: 'interface',
                    props,
                    types: [],
                    extends: [],
                    name: '',
                };
            }
            return this.getTypeNode(typeNode);
        }
        return utils_1.getRef(`typeof ${helpers_1.getTypeRefName(node.exprName)}`);
    }
    getTypeRestNode(node) {
        return {
            kind: 'rest',
            value: this.getTypeNode(node.type),
        };
    }
    getTemplateLiteralNode(node) {
        const parts = [node.head.text];
        for (const span of node.templateSpans) {
            parts.push(this.getTypeNode(span.type));
            parts.push(span.literal.text);
        }
        return {
            kind: 'template',
            parts,
        };
    }
    getConstantNode(node) {
        switch (node.kind) {
            case ts.SyntaxKind.AnyKeyword:
                return {
                    kind: 'any',
                };
            case ts.SyntaxKind.UnknownKeyword:
                return {
                    kind: 'unknown',
                };
            case ts.SyntaxKind.NumberKeyword:
                return {
                    kind: 'number',
                };
            case ts.SyntaxKind.BigIntKeyword:
                return {
                    kind: 'bigint',
                };
            case ts.SyntaxKind.ObjectKeyword:
                return {
                    kind: 'nonPrimitive',
                };
            case ts.SyntaxKind.BooleanKeyword:
                return {
                    kind: 'boolean',
                };
            case ts.SyntaxKind.StringKeyword:
                return {
                    kind: 'string',
                };
            case ts.SyntaxKind.SymbolKeyword:
                return {
                    kind: 'esSymbol',
                };
            case ts.SyntaxKind.VoidKeyword:
                return {
                    kind: 'void',
                };
            case ts.SyntaxKind.UndefinedKeyword:
                return {
                    kind: 'undefined',
                };
            case ts.SyntaxKind.NullKeyword:
                return {
                    kind: 'null',
                };
            case ts.SyntaxKind.NeverKeyword:
                return {
                    kind: 'never',
                };
            case ts.SyntaxKind.ThisKeyword:
            case ts.SyntaxKind.ThisType:
                return utils_1.getRef('this');
        }
        this.printWarning('type node', node);
    }
    getTypeNode(node) {
        if (!node) {
            return {
                kind: 'any',
            };
        }
        else if (ts.isUnionTypeNode(node)) {
            return this.getUnion(node);
        }
        else if (ts.isLiteralTypeNode(node)) {
            return this.getLiteral(node);
        }
        else if (ts.isExpressionWithTypeArguments(node)) {
            return this.getExpressionWithTypeArguments(node);
        }
        else if (ts.isTypeLiteralNode(node)) {
            return this.getTypeLiteral(node);
        }
        else if (ts.isArrayTypeNode(node)) {
            return this.getArray(node);
        }
        else if (ts.isTypeReferenceNode(node)) {
            return this.getTypeReference(node);
        }
        else if (ts.isIndexedAccessTypeNode(node)) {
            return this.getIndexAccess(node);
        }
        else if (ts.isTypeOperatorNode(node)) {
            return this.getTypeOperator(node);
        }
        else if (ts.isMappedTypeNode(node)) {
            return this.getMappedType(node);
        }
        else if ('isConditionalTypeNode' in ts && ts.isConditionalTypeNode(node)) {
            return this.getConditionalType(node);
        }
        else if (ts.isFunctionTypeNode(node)) {
            return this.getMethodSignature(node);
        }
        else if ('isInferTypeNode' in ts && ts.isInferTypeNode(node)) {
            return this.getInfer(node);
        }
        else if (ts.isIntersectionTypeNode(node)) {
            return this.getIntersection(node);
        }
        else if (ts.isParenthesizedTypeNode(node)) {
            return this.getParenthesis(node);
        }
        else if (ts.isConstructorTypeNode(node)) {
            return this.getConstructorCall(node);
        }
        else if ('isTypePredicateNode' in ts && ts.isTypePredicateNode(node)) {
            return this.getPredicate(node);
        }
        else if ('isTupleTypeNode' in ts && ts.isTupleTypeNode(node)) {
            return this.getTuple(node);
        }
        else if ('isTypeQueryNode' in ts && ts.isTypeQueryNode(node)) {
            return this.getTypeQueryNode(node);
        }
        else if ('isRestTypeNode' in ts && ts.isRestTypeNode(node)) {
            return this.getTypeRestNode(node);
        }
        else if ('isTemplateLiteralTypeNode' in ts && ts.isTemplateLiteralTypeNode(node)) {
            return this.getTemplateLiteralNode(node);
        }
        else {
            return this.getConstantNode(node);
        }
    }
    getExtends(nodes) {
        const clauses = [];
        nodes === null || nodes === void 0 ? void 0 : nodes.forEach((node) => {
            if (node.token === ts.SyntaxKind.ExtendsKeyword) {
                clauses.push(...node.types);
            }
            else {
                this.logVerbose(`Skipping unidentified node of kind "${node.kind}" in extends section.`);
            }
        });
        return clauses.map((node) => this.getTypeNode(node));
    }
    getImplements(nodes) {
        const clauses = [];
        nodes === null || nodes === void 0 ? void 0 : nodes.forEach((node) => {
            if (node.token === ts.SyntaxKind.ImplementsKeyword) {
                clauses.push(...node.types);
            }
            else {
                this.logVerbose(`Skipping unidentified node of kind "${node.kind}" in implements section.`);
            }
        });
        return clauses.map((node) => this.getTypeNode(node));
    }
    getDefaultExpression(node) {
        var _a;
        const name = (_a = helpers_1.getExportName(node.name)) !== null && _a !== void 0 ? _a : '_default';
        const expr = node.expression;
        if (ts.isIdentifier(expr)) {
            const decl = helpers_1.getDeclarationFromNode(this.context.checker, expr);
            this.enqueue(decl);
            return utils_1.getRef(expr.text);
        }
        else if (ts.isArrowFunction(expr)) {
            this.includeInContext(expr, () => (Object.assign(Object.assign({}, this.getMethodSignature(expr)), { name })));
        }
        else {
            this.includeInContext(expr, () => ({
                kind: 'const',
                name,
                value: this.getExpression(expr),
                comment: helpers_1.getComment(this.context.checker, node),
            }));
        }
        return utils_1.getRef(name);
    }
    getAlias(node) {
        const name = this.getName(node, node.name.text);
        return {
            kind: 'alias',
            name,
            child: this.getTypeNode(node.type),
            types: this.getTypeParameters(node.typeParameters),
            comment: helpers_1.getComment(this.context.checker, node),
        };
    }
    getClass(node) {
        var _a;
        const { checker } = this.context;
        const type = checker.getTypeAtLocation(node);
        const decls = type.symbol.declarations.filter(ts.isInterfaceDeclaration);
        const name = this.getName(node, (_a = node.name) === null || _a === void 0 ? void 0 : _a.text);
        const docs = helpers_1.getAllJsDocs(checker, decls);
        decls.forEach((m) => this.enqueue(m));
        return {
            kind: 'class',
            name,
            extends: this.getExtends(node.heritageClauses),
            implements: this.getImplements(node.heritageClauses),
            props: this.getClassMembers(node.members),
            types: this.getTypeParameters(node.typeParameters),
            comment: helpers_1.stringifyJsDocs(docs),
        };
    }
    getInterface(node) {
        const { checker, availableImports, root } = this.context;
        const type = checker.getTypeAtLocation(node);
        const decls = type.symbol.declarations
            .filter(ts.isInterfaceDeclaration)
            .filter((m) => !utils_1.isImportedFile(m, root, availableImports));
        const clauses = [];
        const props = [];
        const typeParameters = [];
        const name = this.getName(node, node.name.text);
        const docs = helpers_1.getAllJsDocs(checker, decls);
        decls.forEach((m) => {
            var _a, _b, _c;
            (_a = m.heritageClauses) === null || _a === void 0 ? void 0 : _a.forEach((c) => {
                clauses.includes(c) || includes_1.includeClauses(this.context, clauses, c, docs.tags);
            });
            (_b = m.members) === null || _b === void 0 ? void 0 : _b.forEach((p) => {
                props.includes(p) || includes_1.includeProp(props, p, docs.tags);
            });
            (_c = m.typeParameters) === null || _c === void 0 ? void 0 : _c.forEach((t, i) => {
                typeParameters.length === i && typeParameters.push(t);
            });
        });
        return {
            kind: 'interface',
            name,
            extends: this.getExtends(clauses),
            props: this.getProps(props),
            types: this.getTypeParameters(typeParameters),
            comment: helpers_1.stringifyJsDocs(docs),
        };
    }
    getExpression(node) {
        if (ts.isArrowFunction(node)) {
            return this.getMethodSignature(node);
        }
        else if (ts.isNumericLiteral(node)) {
            return {
                kind: 'literal',
                value: node.text,
            };
        }
        else if (ts.isStringLiteral(node)) {
            return {
                kind: 'literal',
                value: JSON.stringify(node.text),
            };
        }
        else if (node.kind === ts.SyntaxKind.TrueKeyword || node.kind === ts.SyntaxKind.FalseKeyword) {
            return {
                kind: 'boolean',
            };
        }
        else if (ts.isIdentifier(node)) {
            const decl = helpers_1.getDeclarationFromNode(this.context.checker, node);
            this.enqueue(decl);
            return utils_1.getRef(node.text);
        }
        else {
            return this.getInferredType(node);
        }
    }
    getVariableValue(node) {
        if (node.type) {
            return this.getTypeNode(node.type);
        }
        else if (node.initializer) {
            return this.getExpression(node.initializer);
        }
        else {
            const typeNode = this.convertToTypeNodeFromNode(node);
            return this.getTypeNode(typeNode);
        }
    }
    getVariable(node) {
        const name = this.getName(node, node.name.getText());
        return {
            kind: 'const',
            name,
            value: this.getVariableValue(node),
            comment: helpers_1.getComment(this.context.checker, node),
        };
    }
    getEnum(node) {
        const symbol = helpers_1.getSymbol(this.context.checker, node);
        const name = this.getName(node, node.name.text);
        return {
            kind: 'enumLiteral',
            name,
            const: symbol.flags === ts.SymbolFlags.ConstEnum,
            values: this.getEnumMembers(node.members),
            comment: helpers_1.getComment(this.context.checker, node),
        };
    }
    includeInContext(node, createType) {
        const c = this.context;
        const symbol = helpers_1.getSymbol(c.checker, node);
        const global = helpers_1.isGlobal(symbol);
        const { external, fn } = utils_1.getPackage(node, global, c.root, c.availableImports);
        if (!external) {
            this.refs.push(createType());
        }
        else {
            this.logVerbose(`Node from "${fn}" is external and should not be included.`);
        }
    }
    includeExportedTypeAlias(node) {
        this.includeInContext(node, () => this.getAlias(node));
    }
    includeDefaultExport(node) {
        const expr = node.expression;
        if (expr) {
            this.includeInContext(expr, () => utils_1.getDefault(this.getDefaultExpression(node)));
        }
        else if (ts.isFunctionDeclaration(node)) {
            const name = '_default';
            this.includeInContext(node, () => (Object.assign(Object.assign({}, this.getMethodSignature(node)), { name })));
            this.includeInContext(node, () => utils_1.getDefault(utils_1.getRef(name)));
        }
        else if (ts.isClassDeclaration(node)) {
            this.includeInContext(node, () => utils_1.getDefault(this.getClass(node)));
        }
        else {
            this.printWarning('default export', node);
        }
    }
    includeExportedFunction(node) {
        this.includeInContext(node, () => this.getFunctionDeclaration(node));
    }
    includeExportedClass(node) {
        this.includeInContext(node, () => this.getClass(node));
    }
    includeExportedInterface(node) {
        const name = this.getName(node, node.name.text);
        const exists = this.refs.some((m) => m.kind === 'interface' && m.name === name);
        if (!exists) {
            this.includeInContext(node, () => this.getInterface(node));
        }
        else {
            this.logVerbose(`Skipping already included interface "${name}".`);
        }
    }
    includeExportedVariable(node) {
        this.includeInContext(node, () => this.getVariable(node));
    }
    includeExportedVariables(node) {
        node.declarationList.declarations.forEach((decl) => this.includeExportedVariable(decl));
    }
    includeImportedValue(node) {
        const decl = node.symbol.declarations[0];
        this.enqueue(decl);
    }
    includeExportedEnum(node) {
        this.includeInContext(node, () => this.getEnum(node));
    }
    includeSelectedExports(elements) {
        // selected exports here
        elements.forEach((el) => {
            if (el.symbol) {
                const original = this.context.checker.getAliasedSymbol(el.symbol);
                if (original) {
                    const decl = helpers_1.getDeclarationFromSymbol(this.context.checker, original);
                    if (decl) {
                        this.processNode(decl);
                        this.swapName(original.name, el.symbol.name);
                    }
                }
                else if (el.propertyName) {
                    // renamed selected export
                    const symbol = this.context.checker.getExportSpecifierLocalTargetSymbol(el);
                    if (symbol) {
                        const decl = helpers_1.getDeclarationFromSymbol(this.context.checker, symbol);
                        if (decl) {
                            this.processNode(decl);
                            this.swapName(el.propertyName.text, el.symbol.name);
                        }
                    }
                }
            }
        });
    }
    includeStarExports(node) {
        var _a;
        if (node.moduleSpecifier && ts.isStringLiteral(node.moduleSpecifier)) {
            // * exports from a module
            const moduleName = node.moduleSpecifier.text;
            const modules = node.getSourceFile().resolvedModules;
            const fileName = (_a = modules === null || modules === void 0 ? void 0 : modules.get(moduleName)) === null || _a === void 0 ? void 0 : _a.resolvedFileName;
            if (fileName) {
                const newFile = this.context.program.getSourceFile(fileName);
                ts.forEachChild(newFile, (node) => {
                    if (helpers_1.shouldInclude(node)) {
                        this.enqueue(node);
                    }
                });
            }
        }
    }
    includeExportsDeclaration(node) {
        const { exportClause } = node;
        if (exportClause && ts.isNamedExports(exportClause) && exportClause.elements) {
            this.includeSelectedExports(exportClause.elements);
        }
        else {
            this.includeStarExports(node);
        }
    }
    processModule(node) {
        var _a;
        const c = this.context;
        const name = node.name.text;
        const availableImportNames = Object.keys(this.context.availableImports);
        c.modules[name] = this.refs = c.modules[name] || [];
        c.moduleNames[name] = this.names = c.moduleNames[name] || new Map();
        (_a = node.body) === null || _a === void 0 ? void 0 : _a.forEachChild((subNode) => {
            if (helpers_1.isNodeExported(subNode) || availableImportNames.includes(name)) {
                this.enqueue(subNode);
            }
        });
    }
    processNode(node) {
        if (ts.isTypeAliasDeclaration(node)) {
            this.includeExportedTypeAlias(node);
        }
        else if (helpers_1.isDefaultExport(node)) {
            this.includeDefaultExport(node);
        }
        else if (ts.isVariableDeclaration(node)) {
            this.includeExportedVariable(node);
        }
        else if (ts.isVariableStatement(node)) {
            this.includeExportedVariables(node);
        }
        else if (ts.isFunctionDeclaration(node)) {
            this.includeExportedFunction(node);
        }
        else if (ts.isInterfaceDeclaration(node)) {
            this.includeExportedInterface(node);
        }
        else if (ts.isClassDeclaration(node)) {
            this.includeExportedClass(node);
        }
        else if (ts.isImportSpecifier(node)) {
            this.includeImportedValue(node);
        }
        else if (ts.isEnumDeclaration(node)) {
            this.includeExportedEnum(node);
        }
        else if (ts.isTypeLiteralNode(node)) {
            // empty on purpose
            this.logVerbose(`Skipping type literal node: ${node}`);
        }
        else if (ts.isExportDeclaration(node)) {
            this.includeExportsDeclaration(node);
        }
        else if (ts.isModuleDeclaration(node)) {
            this.modules.push(node);
        }
        else if (ts.isImportTypeNode(node)) {
            // empty on purpose
            this.logVerbose(`Skipping import type node: ${node}`);
        }
        else {
            this.printWarning('type', node);
        }
    }
    enqueue(item) {
        if (!item) {
            // empty on purpose
        }
        else if (ts.isEnumMember(item)) {
            this.enqueue(item.parent);
        }
        else if (!this.queue.includes(item) && !this.processed.includes(item)) {
            this.queue.push(item);
        }
    }
    processQueue() {
        while (this.queue.length || this.modules.length) {
            while (this.queue.length > 0) {
                const item = this.queue.shift();
                this.processed.push(item);
                this.processNode(item);
            }
            if (this.modules.length > 0) {
                const mod = this.modules.shift();
                this.processModule(mod);
            }
        }
    }
}
exports.DeclVisitor = DeclVisitor;
