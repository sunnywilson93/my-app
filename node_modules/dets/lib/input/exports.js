"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.includeExports = void 0;
const ts = require("typescript");
const helpers_1 = require("../helpers");
function includeExports(context, key, symbol) {
    const defs = {};
    if (symbol) {
        context.checker.getExportsOfModule(symbol).forEach((exp) => {
            var _a, _b, _c;
            const decl = exp.valueDeclaration || ((_a = exp.declarations) === null || _a === void 0 ? void 0 : _a[0]);
            if (!decl) {
                // skip - not really defined
            }
            else if (ts.isExportSpecifier(decl)) {
                const name = (_b = decl.name) === null || _b === void 0 ? void 0 : _b.text;
                if (name) {
                    defs[name] = helpers_1.getDeclarationFromNode(context.checker, decl);
                }
            }
            else if (ts.isExportAssignment(decl)) {
                defs['default'] = helpers_1.getDeclarationFromNode(context.checker, decl);
            }
            else if (ts.isVariableDeclaration(decl)) {
                defs[helpers_1.getParameterName(decl.name)] = decl;
            }
            else if (ts.isFunctionDeclaration(decl) ||
                ts.isInterfaceDeclaration(decl) ||
                ts.isClassDeclaration(decl) ||
                ts.isTypeAliasDeclaration(decl) ||
                ts.isEnumDeclaration(decl)) {
                const name = helpers_1.isDefaultExport(decl) ? 'default' : (_c = decl.name) === null || _c === void 0 ? void 0 : _c.text;
                if (name) {
                    defs[name] = decl;
                }
            }
            else if (ts.isMethodDeclaration(decl) || ts.isPropertyDeclaration(decl) || ts.isModuleDeclaration(decl)) {
                // skip - mostly from ambient modules
            }
            else if (ts.isImportEqualsDeclaration(decl)) {
                //skip - automatically "introduced"
            }
            else if (ts.isNamespaceExport(decl)) {
                defs[decl.name.text] = decl;
            }
            else {
                context.log.warn(`Skipping import of unknown node (kind: ${decl.kind}).`);
            }
        });
    }
    context.availableImports[key] = defs;
}
exports.includeExports = includeExports;
