"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.retrieveTypings = exports.generateDeclaration = exports.createExcludePlugin = exports.processVisitorContext = exports.addAmbientModules = exports.addAvailableImports = exports.fillExportsFromTypes = exports.fillExportsFromApi = exports.setupVisitorContext = void 0;
const ts = require("typescript");
const input_1 = require("./input");
const output_1 = require("./output");
const helpers_1 = require("./helpers");
const logger_1 = require("./logger");
function setupVisitorContext(name, root, files, imports, log, flags) {
    const rootNames = files.filter((m) => !!m);
    const program = ts.createProgram(rootNames, {
        allowJs: true,
        esModuleInterop: true,
        module: ts.ModuleKind.ESNext,
        moduleResolution: ts.ModuleResolutionKind.NodeJs,
        jsx: ts.JsxEmit.React,
    });
    const checker = program.getTypeChecker();
    const context = {
        modules: {
            [name]: [],
        },
        moduleNames: {
            [name]: new Map(),
        },
        availableImports: {},
        usedImports: [],
        exports: [],
        root,
        checker,
        program,
        log,
        flags,
    };
    addAvailableImports(context, imports);
    addAmbientModules(context, imports);
    return context;
}
exports.setupVisitorContext = setupVisitorContext;
function fillExportsFromApi(context, apiPath, apiName) {
    const api = context.program.getSourceFile(apiPath);
    if (api) {
        ts.forEachChild(api, (node) => input_1.includeApi(context, node, apiName));
    }
    else {
        context.log.error(`Cannot find the "${apiPath}" module. Are you sure it exists? Please run "npm i" to install missing modules.`);
    }
}
exports.fillExportsFromApi = fillExportsFromApi;
function fillExportsFromTypes(context, typingsPath) {
    const tp = context.program.getSourceFile(typingsPath);
    if (tp) {
        ts.forEachChild(tp, (node) => input_1.includeTypings(context, node));
    }
    else {
        context.log.warn('Cannot find the provided typings. Check the "typings" field of your "package.json" for the correct path.');
    }
}
exports.fillExportsFromTypes = fillExportsFromTypes;
function addAvailableImports(context, imports) {
    var _a;
    const sourceFiles = context.program.getSourceFiles();
    const remaining = [...imports];
    context.log.verbose(`Adding ${imports.length} imports from ${sourceFiles.length} source files.`);
    for (const sourceFile of sourceFiles) {
        if (remaining.length === 0) {
            break;
        }
        (_a = sourceFile.resolvedModules) === null || _a === void 0 ? void 0 : _a.forEach((value, key) => {
            const index = remaining.indexOf(key);
            const fileName = value === null || value === void 0 ? void 0 : value.resolvedFileName;
            if (!fileName) {
                context.log.verbose(`Skipping module without filename: ${value}.`);
            }
            else if (index === -1) {
                context.log.verbose(`Skipping module "${fileName}" as it does not match.`);
            }
            else {
                const file = context.program.getSourceFile(fileName);
                input_1.includeExports(context, key, file === null || file === void 0 ? void 0 : file.symbol);
                remaining.splice(index, 1);
            }
        });
    }
}
exports.addAvailableImports = addAvailableImports;
function addAmbientModules(context, imports) {
    var _a, _b, _c;
    const modules = context.checker.getAmbientModules();
    context.log.verbose(`Adding ${modules.length} ambient modules.`);
    for (const module of modules) {
        const file = (_c = (_b = (_a = module.declarations) === null || _a === void 0 ? void 0 : _a[0]) === null || _b === void 0 ? void 0 : _b.getSourceFile()) === null || _c === void 0 ? void 0 : _c.fileName;
        const lib = helpers_1.getLibName(file, context.root);
        if (imports.includes(lib)) {
            input_1.includeExports(context, module.name, module);
        }
    }
}
exports.addAmbientModules = addAmbientModules;
function runAll(context, plugins, type) {
    const { log } = context;
    log.verbose(`Running the ${type}" plugins.`);
    plugins
        .filter((p) => p.type === type)
        .forEach((p) => {
        try {
            p.run(context);
        }
        catch (ex) {
            log.error(`The plugin "${p.name}" crashed: ${ex}`);
        }
    });
}
function processVisitorContext(context, plugins) {
    const { log } = context;
    runAll(context, plugins, 'before-init');
    const visitor = new input_1.DeclVisitor(context);
    runAll(context, plugins, 'before-process');
    log.verbose('Processing the queue.');
    visitor.processQueue();
    runAll(context, plugins, 'after-process');
    runAll(context, plugins, 'before-stringify');
    log.verbose('Generating the string representation.');
}
exports.processVisitorContext = processVisitorContext;
function createExcludePlugin(moduleNames) {
    return {
        type: 'after-process',
        name: 'exclude-plugin',
        run(context) {
            for (const name of moduleNames) {
                delete context.modules[name];
            }
        },
    };
}
exports.createExcludePlugin = createExcludePlugin;
function generateDeclaration(options) {
    const { name, root = process.cwd(), imports = [], files = [], types = [], apis = [], plugins = [], logger = logger_1.defaultLogger, logLevel = 3, noIgnore = false, } = options;
    const log = logger_1.wrapLogger(logger, logLevel);
    log.verbose(`Aggregating the sources from "${root}".`);
    const sources = [
        ...files.map((file) => helpers_1.findAppRoot(root, file)),
        ...apis.map((api) => helpers_1.findAppRoot(root, api.file)),
        ...types.map((type) => helpers_1.findAppRoot(root, type)),
    ];
    log.verbose(`Setting up a visitor context for "${name}".`);
    const context = setupVisitorContext(name, root, sources, imports, log, {
        noIgnore,
    });
    log.verbose(`Starting API gathering in "${root}".`);
    for (const api of apis) {
        const path = helpers_1.findAppRoot(root, api.file);
        fillExportsFromApi(context, path, api.name);
    }
    log.verbose(`Starting type aggregation from "${root}".`);
    for (const type of types) {
        const path = helpers_1.findAppRoot(root, type);
        fillExportsFromTypes(context, path);
    }
    log.verbose(`Processing the visitor context.`);
    processVisitorContext(context, plugins);
    return output_1.stringifyDeclaration(context);
}
exports.generateDeclaration = generateDeclaration;
function retrieveTypings(options) {
    const name = 'main';
    const { root = process.cwd(), imports = [], files = [], types = [], plugins = [], logger = logger_1.defaultLogger, logLevel = 3, noIgnore = false, } = options;
    const log = logger_1.wrapLogger(logger, logLevel);
    log.verbose(`Aggregating the sources from "${root}".`);
    const sources = [...files.map((file) => helpers_1.findAppRoot(root, file)), ...types.map((type) => helpers_1.findAppRoot(root, type))];
    log.verbose(`Setting up a visitor context for "${name}".`);
    const context = setupVisitorContext(name, root, sources, imports, log, {
        noIgnore,
    });
    log.verbose(`Starting type aggregation from "${root}".`);
    for (const type of types) {
        const path = helpers_1.findAppRoot(root, type);
        fillExportsFromTypes(context, path);
    }
    log.verbose(`Processing the visitor context.`);
    processVisitorContext(context, plugins);
    return context.modules.main;
}
exports.retrieveTypings = retrieveTypings;
