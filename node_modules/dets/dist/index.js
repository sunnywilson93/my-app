module.exports =
/******/ (function(modules, runtime) { // webpackBootstrap
/******/ 	"use strict";
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		var threw = true;
/******/ 		try {
/******/ 			modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 			threw = false;
/******/ 		} finally {
/******/ 			if(threw) delete installedModules[moduleId];
/******/ 		}
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	__webpack_require__.ab = __dirname + "/";
/******/
/******/ 	// the startup function
/******/ 	function startup() {
/******/ 		// Load entry module and return exports
/******/ 		return __webpack_require__(325);
/******/ 	};
/******/
/******/ 	// run startup
/******/ 	return startup();
/******/ })
/************************************************************************/
/******/ ({

/***/ 33:
/***/ (function(__unusedmodule, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.includeTypings = void 0;
const helpers_1 = __webpack_require__(361);
function includeTypings(context, node) {
    if (helpers_1.shouldInclude(node)) {
        context.exports.push(node);
    }
    else {
        context.log.verbose(`Skipping typings from node: ${node}`);
    }
}
exports.includeTypings = includeTypings;


/***/ }),

/***/ 34:
/***/ (function(module) {

module.exports = require("typescript");

/***/ }),

/***/ 51:
/***/ (function(__unusedmodule, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.stringifyModule = void 0;
const exports_1 = __webpack_require__(376);
const helpers_1 = __webpack_require__(361);
function stringifyModule(name, refs) {
    const content = exports_1.stringifyExports(refs);
    const formattedContent = helpers_1.formatContent(content);
    return `declare module "${name}" {\n${formattedContent}}`;
}
exports.stringifyModule = stringifyModule;


/***/ }),

/***/ 72:
/***/ (function(__unusedmodule, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.DeclVisitor = void 0;
const ts = __webpack_require__(34);
const utils_1 = __webpack_require__(276);
const includes_1 = __webpack_require__(695);
const helpers_1 = __webpack_require__(361);
class DeclVisitor {
    constructor(context) {
        var _a, _b, _c;
        this.context = context;
        this.queue = [];
        this.modules = [];
        this.processed = [];
        const [defaultModule] = Object.keys((_a = context.modules) !== null && _a !== void 0 ? _a : {});
        this.refs = (_b = context.modules[defaultModule]) !== null && _b !== void 0 ? _b : [];
        this.names = (_c = context.moduleNames[defaultModule]) !== null && _c !== void 0 ? _c : new Map();
        for (const node of context.exports) {
            this.enqueue(node);
        }
    }
    logVerbose(message) {
        this.context.log.verbose(message);
    }
    logWarn(message) {
        this.context.log.warn(message);
    }
    printWarning(type, node) {
        var _a;
        this.logWarn(`Could not resolve ${type} at position ${node.pos} of "${(_a = node.getSourceFile()) === null || _a === void 0 ? void 0 : _a.fileName}". Kind: ${node.kind}.`);
    }
    swapName(oldName, newName) {
        const refs = this.refs;
        const last = refs.pop();
        if (!last) {
            // empty on purpose
        }
        else if (last.kind === 'default') {
            if (last.value.kind === 'ref') {
                const name = last.value.refName;
                for (let i = refs.length; i--;) {
                    const ref = refs[i];
                    if (ref.name === name) {
                        refs.splice(i, 1, Object.assign(Object.assign({}, ref), { name: newName }));
                        break;
                    }
                }
            }
        }
        else if ('name' in last && last.name === oldName) {
            refs.push(Object.assign(Object.assign({}, last), { name: newName }));
        }
        else {
            refs.push(last);
        }
    }
    findName(node) {
        return this.names.get(node);
    }
    createName(name) {
        const altStart = `${name}___`;
        const available = new Set();
        for (const m of this.names.values()) {
            if (m === name || m.startsWith(altStart)) {
                available.add(m);
            }
        }
        const count = available.size;
        if (count) {
            return `${altStart}${count}`;
        }
        return name;
    }
    getName(node, suggested) {
        var _a, _b;
        const existing = this.findName(node);
        if (!existing) {
            this.logVerbose(`Missing "name". Retrieving with suggestion "${suggested}".`);
            const name = this.createName(suggested);
            const decls = (_b = (_a = node.symbol) === null || _a === void 0 ? void 0 : _a.declarations) !== null && _b !== void 0 ? _b : [node];
            decls.forEach((decl) => this.names.set(decl, name));
            return name;
        }
        return existing;
    }
    normalizeName(node) {
        var _a, _b;
        const c = this.context;
        const symbol = (_b = (_a = node.symbol) !== null && _a !== void 0 ? _a : node.aliasSymbol) !== null && _b !== void 0 ? _b : c.checker.getSymbolAtLocation(node);
        const global = helpers_1.isGlobal(symbol);
        const { moduleName, lib, symbolName } = utils_1.getPackage(node, global, c.root, c.availableImports);
        if (!lib) {
            const name = global ? helpers_1.fullyQualifiedName(symbol, '_') : helpers_1.getSymbolName(symbol);
            return this.getName(node, name);
        }
        else if (global) {
            return helpers_1.fullyQualifiedName(symbol, '.');
        }
        else {
            return utils_1.createBinding(c, moduleName, symbolName !== null && symbolName !== void 0 ? symbolName : helpers_1.getSymbolName(symbol));
        }
    }
    convertToTypeNodeFromType(type) {
        const c = this.context.checker;
        return c.typeToTypeNode(type, undefined, ts.NodeBuilderFlags.NoTruncation);
    }
    convertToTypeNodeFromNode(node) {
        const type = this.context.checker.getTypeAtLocation(node);
        return this.convertToTypeNodeFromType(type);
    }
    valueFromLiteral(node) {
        var _a;
        switch (node.literal.kind) {
            case ts.SyntaxKind.StringLiteral:
                return JSON.stringify(node.literal.text);
            case ts.SyntaxKind.TrueKeyword:
                return 'true';
            case ts.SyntaxKind.FalseKeyword:
                return 'false';
            case ts.SyntaxKind.NumericLiteral:
            case ts.SyntaxKind.BigIntLiteral:
                return node.literal.text;
            default:
                this.logVerbose(`No match for literal node kind "${node.literal.kind}". Trying to get from type node...`);
                const type = this.context.checker.getTypeFromTypeNode(node);
                return (_a = type === null || type === void 0 ? void 0 : type.intrinsicName) !== null && _a !== void 0 ? _a : type === null || type === void 0 ? void 0 : type.value;
        }
    }
    getInferredType(node) {
        const typeNode = this.convertToTypeNodeFromNode(node);
        return this.getTypeNode(typeNode);
    }
    getUnion(node) {
        return {
            kind: 'union',
            types: node.types.map((m) => this.getNode(m)),
        };
    }
    getLiteral(node) {
        return {
            kind: 'literal',
            value: this.valueFromLiteral(node),
        };
    }
    getNode(node) {
        if (ts.isTypeNode(node)) {
            return this.getTypeNode(node);
        }
        else if (ts.isTypeAliasDeclaration(node) ||
            ts.isFunctionDeclaration(node) ||
            ts.isInterfaceDeclaration(node) ||
            ts.isClassDeclaration(node)) {
            this.enqueue(node);
            return utils_1.getRef(this.normalizeName(node), this.getTypeParameters(node.typeParameters));
        }
        else if (helpers_1.isDefaultExport(node) || ts.isVariableDeclaration(node) || ts.isVariableStatement(node)) {
            this.enqueue(node);
            return utils_1.getRef(this.normalizeName(node));
        }
        else if (ts.isPropertyAssignment(node)) {
            return {
                kind: 'prop',
                modifiers: helpers_1.getModifiers(node.symbol),
                name: node.symbol.name,
                optional: node.questionToken !== undefined,
                valueType: this.getExpression(node.initializer),
            };
        }
        this.logVerbose(`Node is presumably a reference. Found kind "${node.kind}".`);
        return utils_1.getRef(node.symbol.name);
    }
    getPropDeclaration(node) {
        var _a;
        const type = (_a = node.type) !== null && _a !== void 0 ? _a : this.convertToTypeNodeFromNode(node);
        return this.getTypeNode(type);
    }
    getPropValue(node) {
        if (ts.isPropertySignature(node)) {
            return this.getTypeNode(node.type);
        }
        else if (ts.isMethodSignature(node)) {
            return this.getMethodSignature(node);
        }
        else if (ts.isPropertyDeclaration(node)) {
            return this.getPropDeclaration(node);
        }
        else if (ts.isMethodDeclaration(node)) {
            return this.getMethodSignature(node);
        }
        this.printWarning('property', node);
    }
    getNormalProp(node) {
        var _a, _b;
        const { checker, flags } = this.context;
        const canDrop = !flags.noIgnore;
        const comment = helpers_1.getCommentOrDrop(checker, (_b = (_a = node.emitNode) === null || _a === void 0 ? void 0 : _a.commentRange) !== null && _b !== void 0 ? _b : node, canDrop);
        if (typeof comment === 'string') {
            return {
                kind: 'prop',
                name: helpers_1.getPropName(node.name),
                modifiers: helpers_1.getModifiers(node.symbol),
                optional: node.questionToken !== undefined,
                comment,
                valueType: this.getPropValue(node),
            };
        }
        this.logVerbose(`The prop "${helpers_1.getPropName(node.name)}" was skipped due to @ignore.`);
        return undefined;
    }
    getIndexProp(node) {
        return {
            kind: 'index',
            parameters: this.getFunctionParameters(node.parameters),
            optional: node.questionToken !== undefined,
            valueType: this.getTypeNode(node.type),
        };
    }
    getConstructor(node) {
        return {
            kind: 'constructor',
            parameters: this.getFunctionParameters(node.parameters),
            comment: helpers_1.getComment(this.context.checker, node),
        };
    }
    getClassMember(node) {
        const { checker, flags } = this.context;
        const canDrop = !flags.noIgnore;
        const comment = helpers_1.getCommentOrDrop(checker, node, canDrop);
        if (typeof comment === 'string') {
            return {
                kind: 'prop',
                name: node.name.getText(),
                modifiers: helpers_1.getModifiers(node.symbol),
                optional: false,
                comment,
                valueType: this.getPropValue(node),
            };
        }
        this.logVerbose(`The member "${node.name.getText()}" was skipped due to @ignore.`);
        return undefined;
    }
    getProps(nodes) {
        const props = [];
        nodes === null || nodes === void 0 ? void 0 : nodes.forEach((node) => {
            if (ts.isIndexSignatureDeclaration(node)) {
                props.push(this.getIndexProp(node));
            }
            else if (ts.isCallSignatureDeclaration(node)) {
                props.push(this.getMethodSignature(node));
            }
            else if (ts.isConstructSignatureDeclaration(node)) {
                props.push(this.getConstructorCall(node));
            }
            else if (ts.isGetAccessor(node)) {
                const prop = this.getGetAccessor(node);
                prop && props.push(prop);
            }
            else if (ts.isSetAccessor(node)) {
                const prop = this.getSetAccessor(node);
                prop && props.push(prop);
            }
            else {
                this.logVerbose(`Getting props - assuming node of kind "${node === null || node === void 0 ? void 0 : node.kind}" is a normal prop.`);
                const prop = this.getNormalProp(node);
                prop && props.push(prop);
            }
        });
        return props;
    }
    getClassMembers(nodes) {
        const members = [];
        nodes === null || nodes === void 0 ? void 0 : nodes.forEach((node) => {
            if (ts.isConstructorDeclaration(node)) {
                members.push(this.getConstructor(node));
            }
            else if (ts.isCallSignatureDeclaration(node)) {
                members.push(this.getMethodSignature(node));
            }
            else if (ts.isConstructSignatureDeclaration(node)) {
                members.push(this.getConstructorCall(node));
            }
            else if (ts.isGetAccessor(node)) {
                const member = this.getGetAccessor(node);
                member && members.push(member);
            }
            else if (ts.isSetAccessor(node)) {
                const member = this.getSetAccessor(node);
                member && members.push(member);
            }
            else if (ts.isIndexSignatureDeclaration(node)) {
                members.push(this.getIndexProp(node));
            }
            else {
                this.logVerbose(`Getting class members - assuming node of kind "${node === null || node === void 0 ? void 0 : node.kind}" is a class member.`);
                const member = this.getClassMember(node);
                member && members.push(member);
            }
        });
        return members;
    }
    getEnumMember(node) {
        const value = node.initializer;
        return {
            kind: 'member',
            name: helpers_1.getPropName(node.name),
            value: value && this.getExpression(value),
            comment: helpers_1.getComment(this.context.checker, node),
        };
    }
    getEnumMembers(nodes) {
        var _a;
        return (_a = nodes === null || nodes === void 0 ? void 0 : nodes.map((node) => this.getEnumMember(node))) !== null && _a !== void 0 ? _a : [];
    }
    getReturnType(node) {
        var _a;
        const checker = this.context.checker;
        const type = (_a = node.type) !== null && _a !== void 0 ? _a : this.convertToTypeNodeFromType(checker.getReturnTypeOfSignature(checker.getSignatureFromDeclaration(node)));
        return this.getTypeNode(type);
    }
    getFunctionDeclaration(node) {
        const name = this.getName(node, node.name.text);
        return Object.assign(Object.assign({}, this.getMethodSignature(node)), { name });
    }
    getMethodSignature(node) {
        return {
            kind: 'function',
            name: undefined,
            parameters: this.getFunctionParameters(node.parameters),
            returnType: this.getReturnType(node),
            types: this.getTypeParameters(node.typeParameters),
            comment: helpers_1.getComment(this.context.checker, node),
        };
    }
    getConstructorCall(node) {
        return {
            kind: 'new',
            parameters: this.getFunctionParameters(node.parameters),
            returnType: this.getTypeNode(node.type),
            types: this.getTypeParameters(node.typeParameters),
            comment: helpers_1.getComment(this.context.checker, node),
        };
    }
    getTypeParameter(node) {
        return {
            kind: 'typeParameter',
            parameter: utils_1.getRef(node.name.text),
            constraint: node.constraint && this.getTypeNode(node.constraint),
            default: node.default && this.getTypeNode(node.default),
        };
    }
    getTypeParameters(nodes) {
        var _a;
        return (_a = nodes === null || nodes === void 0 ? void 0 : nodes.map((node) => this.getTypeParameter(node))) !== null && _a !== void 0 ? _a : [];
    }
    getTypeArguments(nodes) {
        var _a;
        return (_a = nodes === null || nodes === void 0 ? void 0 : nodes.map((node) => this.getTypeNode(node))) !== null && _a !== void 0 ? _a : [];
    }
    getFunctionParameterValue(node) {
        if (node.type) {
            return this.getTypeNode(node.type);
        }
        else if (node.initializer) {
            return this.getExpression(node.initializer);
        }
        else {
            this.logVerbose(`Found unidentified node of kind "${node.kind}" in function parameter value. Falling back to "any".`);
            return {
                kind: 'any',
            };
        }
    }
    getFunctionParameter(node) {
        return {
            kind: 'parameter',
            param: helpers_1.getParameterName(node.name),
            spread: node.dotDotDotToken !== undefined,
            optional: node.questionToken !== undefined || node.initializer !== undefined,
            modifiers: helpers_1.getModifiers(node.symbol),
            value: this.getFunctionParameterValue(node),
        };
    }
    getFunctionParameters(nodes) {
        var _a;
        return (_a = nodes === null || nodes === void 0 ? void 0 : nodes.map((node) => this.getFunctionParameter(node))) !== null && _a !== void 0 ? _a : [];
    }
    getIndexAccess(node) {
        return {
            kind: 'indexedAccess',
            index: this.getTypeNode(node.indexType),
            object: this.getTypeNode(node.objectType),
        };
    }
    getTypeOperator(node) {
        switch (node.operator) {
            case ts.SyntaxKind.KeyOfKeyword:
                return {
                    kind: 'keyof',
                    value: this.getTypeNode(node.type),
                };
            case ts.SyntaxKind.UniqueKeyword:
                return {
                    kind: 'unique',
                    value: this.getTypeNode(node.type),
                };
            case ts.SyntaxKind.ReadonlyKeyword:
                return {
                    kind: 'readonly',
                    value: this.getTypeNode(node.type),
                };
            default:
                this.logWarn(`Found unknown type operator node of kind "${node.kind}".`);
        }
    }
    getMappedType(node) {
        const p = node.typeParameter;
        return {
            kind: 'interface',
            name: undefined,
            extends: [],
            props: [],
            types: [],
            comment: helpers_1.getComment(this.context.checker, node),
            mapped: {
                kind: 'mapped',
                constraint: this.getTypeNode(p.constraint),
                name: p.name.text,
                optional: node.questionToken !== undefined,
                value: this.getTypeNode(node.type),
            },
        };
    }
    getConditionalType(node) {
        return {
            kind: 'conditional',
            alternate: this.getTypeNode(node.falseType),
            check: this.getTypeNode(node.checkType),
            extends: this.getTypeNode(node.extendsType),
            primary: this.getTypeNode(node.trueType),
        };
    }
    getPredicate(node) {
        return {
            kind: 'predicate',
            name: helpers_1.getPredicateName(node.parameterName),
            value: this.getTypeNode(node.type),
        };
    }
    getSetAccessor(node) {
        const { checker, flags } = this.context;
        const canDrop = !flags.noIgnore;
        const comment = helpers_1.getCommentOrDrop(checker, node, canDrop);
        if (typeof comment === 'string') {
            return {
                kind: 'set',
                name: helpers_1.getPropName(node.name),
                parameters: this.getFunctionParameters(node.parameters),
                comment,
                modifiers: helpers_1.getModifiers(node.symbol),
            };
        }
        this.logVerbose(`The setter "${helpers_1.getPropName(node.name)}" was skipped due to @ignore.`);
        return undefined;
    }
    getGetAccessor(node) {
        const { checker, flags } = this.context;
        const canDrop = !flags.noIgnore;
        const comment = helpers_1.getCommentOrDrop(checker, node, canDrop);
        if (typeof comment === 'string') {
            return {
                kind: 'get',
                name: helpers_1.getPropName(node.name),
                type: this.getReturnType(node),
                comment,
                modifiers: helpers_1.getModifiers(node.symbol),
            };
        }
        this.logVerbose(`The getter "${helpers_1.getPropName(node.name)}" was skipped due to @ignore.`);
        return undefined;
    }
    getTypeReference(node) {
        const c = this.context.checker;
        const decl = helpers_1.getDeclarationFromNode(c, node);
        if (decl && !ts.isTypeParameterDeclaration(decl)) {
            this.enqueue(decl);
            return utils_1.getRef(this.normalizeName(decl), this.getTypeArguments(node.typeArguments));
        }
        return utils_1.getRef(helpers_1.getTypeRefName(node.typeName), this.getTypeArguments(node.typeArguments));
    }
    getTypeLiteral(node) {
        return {
            kind: 'interface',
            name: undefined,
            comment: helpers_1.getComment(this.context.checker, node),
            extends: [],
            props: this.getProps(node.members),
            types: [],
        };
    }
    getExpressionWithTypeArguments(node) {
        const decl = helpers_1.getDeclarationFromNode(this.context.checker, node.expression);
        this.enqueue(decl);
        return utils_1.getRef(this.normalizeName(decl), this.getTypeArguments(node.typeArguments));
    }
    getArray(node) {
        return utils_1.getRef('Array', [this.getTypeNode(node.elementType)]);
    }
    getInfer(node) {
        return {
            kind: 'infer',
            parameter: this.getTypeParameter(node.typeParameter),
        };
    }
    getIntersection(node) {
        return {
            kind: 'intersection',
            types: node.types.map((n) => this.getTypeNode(n)),
        };
    }
    getTuple(node) {
        var _a;
        return {
            kind: 'tuple',
            types: ((_a = node['elementTypes']) !== null && _a !== void 0 ? _a : node.elements).map((n) => this.getTypeNode(n)),
        };
    }
    getParenthesis(node) {
        return {
            kind: 'parenthesis',
            value: this.getTypeNode(node.type),
        };
    }
    getTypeQueryNode(node) {
        const symbol = this.context.checker.getSymbolAtLocation(node.exprName);
        if (symbol !== undefined) {
            const type = this.context.checker.getTypeOfSymbolAtLocation(symbol, node);
            const typeNode = this.convertToTypeNodeFromType(type);
            if (typeNode && ts.isImportTypeNode(typeNode)) {
                const props = type
                    .getProperties()
                    .map((prop) => ({
                    name: prop.name,
                    decl: prop.valueDeclaration,
                }))
                    .map((m) => ({
                    name: m.name,
                    type: m.decl && this.context.checker.getTypeOfSymbolAtLocation(m.decl.symbol, m.decl),
                }))
                    .map((m) => ({
                    name: m.name,
                    node: m.type && this.convertToTypeNodeFromType(m.type),
                }))
                    .map((m) => ({
                    name: m.name,
                    modifiers: '',
                    optional: false,
                    kind: 'prop',
                    valueType: this.getTypeNode(m.node),
                }));
                return {
                    kind: 'interface',
                    props,
                    types: [],
                    extends: [],
                    name: '',
                };
            }
            return this.getTypeNode(typeNode);
        }
        return utils_1.getRef(`typeof ${helpers_1.getTypeRefName(node.exprName)}`);
    }
    getTypeRestNode(node) {
        return {
            kind: 'rest',
            value: this.getTypeNode(node.type),
        };
    }
    getTemplateLiteralNode(node) {
        const parts = [node.head.text];
        for (const span of node.templateSpans) {
            parts.push(this.getTypeNode(span.type));
            parts.push(span.literal.text);
        }
        return {
            kind: 'template',
            parts,
        };
    }
    getConstantNode(node) {
        switch (node.kind) {
            case ts.SyntaxKind.AnyKeyword:
                return {
                    kind: 'any',
                };
            case ts.SyntaxKind.UnknownKeyword:
                return {
                    kind: 'unknown',
                };
            case ts.SyntaxKind.NumberKeyword:
                return {
                    kind: 'number',
                };
            case ts.SyntaxKind.BigIntKeyword:
                return {
                    kind: 'bigint',
                };
            case ts.SyntaxKind.ObjectKeyword:
                return {
                    kind: 'nonPrimitive',
                };
            case ts.SyntaxKind.BooleanKeyword:
                return {
                    kind: 'boolean',
                };
            case ts.SyntaxKind.StringKeyword:
                return {
                    kind: 'string',
                };
            case ts.SyntaxKind.SymbolKeyword:
                return {
                    kind: 'esSymbol',
                };
            case ts.SyntaxKind.VoidKeyword:
                return {
                    kind: 'void',
                };
            case ts.SyntaxKind.UndefinedKeyword:
                return {
                    kind: 'undefined',
                };
            case ts.SyntaxKind.NullKeyword:
                return {
                    kind: 'null',
                };
            case ts.SyntaxKind.NeverKeyword:
                return {
                    kind: 'never',
                };
            case ts.SyntaxKind.ThisKeyword:
            case ts.SyntaxKind.ThisType:
                return utils_1.getRef('this');
        }
        this.printWarning('type node', node);
    }
    getTypeNode(node) {
        if (!node) {
            return {
                kind: 'any',
            };
        }
        else if (ts.isUnionTypeNode(node)) {
            return this.getUnion(node);
        }
        else if (ts.isLiteralTypeNode(node)) {
            return this.getLiteral(node);
        }
        else if (ts.isExpressionWithTypeArguments(node)) {
            return this.getExpressionWithTypeArguments(node);
        }
        else if (ts.isTypeLiteralNode(node)) {
            return this.getTypeLiteral(node);
        }
        else if (ts.isArrayTypeNode(node)) {
            return this.getArray(node);
        }
        else if (ts.isTypeReferenceNode(node)) {
            return this.getTypeReference(node);
        }
        else if (ts.isIndexedAccessTypeNode(node)) {
            return this.getIndexAccess(node);
        }
        else if (ts.isTypeOperatorNode(node)) {
            return this.getTypeOperator(node);
        }
        else if (ts.isMappedTypeNode(node)) {
            return this.getMappedType(node);
        }
        else if ('isConditionalTypeNode' in ts && ts.isConditionalTypeNode(node)) {
            return this.getConditionalType(node);
        }
        else if (ts.isFunctionTypeNode(node)) {
            return this.getMethodSignature(node);
        }
        else if ('isInferTypeNode' in ts && ts.isInferTypeNode(node)) {
            return this.getInfer(node);
        }
        else if (ts.isIntersectionTypeNode(node)) {
            return this.getIntersection(node);
        }
        else if (ts.isParenthesizedTypeNode(node)) {
            return this.getParenthesis(node);
        }
        else if (ts.isConstructorTypeNode(node)) {
            return this.getConstructorCall(node);
        }
        else if ('isTypePredicateNode' in ts && ts.isTypePredicateNode(node)) {
            return this.getPredicate(node);
        }
        else if ('isTupleTypeNode' in ts && ts.isTupleTypeNode(node)) {
            return this.getTuple(node);
        }
        else if ('isTypeQueryNode' in ts && ts.isTypeQueryNode(node)) {
            return this.getTypeQueryNode(node);
        }
        else if ('isRestTypeNode' in ts && ts.isRestTypeNode(node)) {
            return this.getTypeRestNode(node);
        }
        else if ('isTemplateLiteralTypeNode' in ts && ts.isTemplateLiteralTypeNode(node)) {
            return this.getTemplateLiteralNode(node);
        }
        else {
            return this.getConstantNode(node);
        }
    }
    getExtends(nodes) {
        const clauses = [];
        nodes === null || nodes === void 0 ? void 0 : nodes.forEach((node) => {
            if (node.token === ts.SyntaxKind.ExtendsKeyword) {
                clauses.push(...node.types);
            }
            else {
                this.logVerbose(`Skipping unidentified node of kind "${node.kind}" in extends section.`);
            }
        });
        return clauses.map((node) => this.getTypeNode(node));
    }
    getImplements(nodes) {
        const clauses = [];
        nodes === null || nodes === void 0 ? void 0 : nodes.forEach((node) => {
            if (node.token === ts.SyntaxKind.ImplementsKeyword) {
                clauses.push(...node.types);
            }
            else {
                this.logVerbose(`Skipping unidentified node of kind "${node.kind}" in implements section.`);
            }
        });
        return clauses.map((node) => this.getTypeNode(node));
    }
    getDefaultExpression(node) {
        var _a;
        const name = (_a = helpers_1.getExportName(node.name)) !== null && _a !== void 0 ? _a : '_default';
        const expr = node.expression;
        if (ts.isIdentifier(expr)) {
            const decl = helpers_1.getDeclarationFromNode(this.context.checker, expr);
            this.enqueue(decl);
            return utils_1.getRef(expr.text);
        }
        else if (ts.isArrowFunction(expr)) {
            this.includeInContext(expr, () => (Object.assign(Object.assign({}, this.getMethodSignature(expr)), { name })));
        }
        else {
            this.includeInContext(expr, () => ({
                kind: 'const',
                name,
                value: this.getExpression(expr),
                comment: helpers_1.getComment(this.context.checker, node),
            }));
        }
        return utils_1.getRef(name);
    }
    getAlias(node) {
        const name = this.getName(node, node.name.text);
        return {
            kind: 'alias',
            name,
            child: this.getTypeNode(node.type),
            types: this.getTypeParameters(node.typeParameters),
            comment: helpers_1.getComment(this.context.checker, node),
        };
    }
    getClass(node) {
        var _a;
        const { checker } = this.context;
        const type = checker.getTypeAtLocation(node);
        const decls = type.symbol.declarations.filter(ts.isInterfaceDeclaration);
        const name = this.getName(node, (_a = node.name) === null || _a === void 0 ? void 0 : _a.text);
        const docs = helpers_1.getAllJsDocs(checker, decls);
        decls.forEach((m) => this.enqueue(m));
        return {
            kind: 'class',
            name,
            extends: this.getExtends(node.heritageClauses),
            implements: this.getImplements(node.heritageClauses),
            props: this.getClassMembers(node.members),
            types: this.getTypeParameters(node.typeParameters),
            comment: helpers_1.stringifyJsDocs(docs),
        };
    }
    getInterface(node) {
        const { checker, availableImports, root } = this.context;
        const type = checker.getTypeAtLocation(node);
        const decls = type.symbol.declarations
            .filter(ts.isInterfaceDeclaration)
            .filter((m) => !utils_1.isImportedFile(m, root, availableImports));
        const clauses = [];
        const props = [];
        const typeParameters = [];
        const name = this.getName(node, node.name.text);
        const docs = helpers_1.getAllJsDocs(checker, decls);
        decls.forEach((m) => {
            var _a, _b, _c;
            (_a = m.heritageClauses) === null || _a === void 0 ? void 0 : _a.forEach((c) => {
                clauses.includes(c) || includes_1.includeClauses(this.context, clauses, c, docs.tags);
            });
            (_b = m.members) === null || _b === void 0 ? void 0 : _b.forEach((p) => {
                props.includes(p) || includes_1.includeProp(props, p, docs.tags);
            });
            (_c = m.typeParameters) === null || _c === void 0 ? void 0 : _c.forEach((t, i) => {
                typeParameters.length === i && typeParameters.push(t);
            });
        });
        return {
            kind: 'interface',
            name,
            extends: this.getExtends(clauses),
            props: this.getProps(props),
            types: this.getTypeParameters(typeParameters),
            comment: helpers_1.stringifyJsDocs(docs),
        };
    }
    getExpression(node) {
        if (ts.isArrowFunction(node)) {
            return this.getMethodSignature(node);
        }
        else if (ts.isNumericLiteral(node)) {
            return {
                kind: 'literal',
                value: node.text,
            };
        }
        else if (ts.isStringLiteral(node)) {
            return {
                kind: 'literal',
                value: JSON.stringify(node.text),
            };
        }
        else if (node.kind === ts.SyntaxKind.TrueKeyword || node.kind === ts.SyntaxKind.FalseKeyword) {
            return {
                kind: 'boolean',
            };
        }
        else if (ts.isIdentifier(node)) {
            const decl = helpers_1.getDeclarationFromNode(this.context.checker, node);
            this.enqueue(decl);
            return utils_1.getRef(node.text);
        }
        else {
            return this.getInferredType(node);
        }
    }
    getVariableValue(node) {
        if (node.type) {
            return this.getTypeNode(node.type);
        }
        else if (node.initializer) {
            return this.getExpression(node.initializer);
        }
        else {
            const typeNode = this.convertToTypeNodeFromNode(node);
            return this.getTypeNode(typeNode);
        }
    }
    getVariable(node) {
        const name = this.getName(node, node.name.getText());
        return {
            kind: 'const',
            name,
            value: this.getVariableValue(node),
            comment: helpers_1.getComment(this.context.checker, node),
        };
    }
    getEnum(node) {
        const symbol = helpers_1.getSymbol(this.context.checker, node);
        const name = this.getName(node, node.name.text);
        return {
            kind: 'enumLiteral',
            name,
            const: symbol.flags === ts.SymbolFlags.ConstEnum,
            values: this.getEnumMembers(node.members),
            comment: helpers_1.getComment(this.context.checker, node),
        };
    }
    includeInContext(node, createType) {
        const c = this.context;
        const symbol = helpers_1.getSymbol(c.checker, node);
        const global = helpers_1.isGlobal(symbol);
        const { external, fn } = utils_1.getPackage(node, global, c.root, c.availableImports);
        if (!external) {
            this.refs.push(createType());
        }
        else {
            this.logVerbose(`Node from "${fn}" is external and should not be included.`);
        }
    }
    includeExportedTypeAlias(node) {
        this.includeInContext(node, () => this.getAlias(node));
    }
    includeDefaultExport(node) {
        const expr = node.expression;
        if (expr) {
            this.includeInContext(expr, () => utils_1.getDefault(this.getDefaultExpression(node)));
        }
        else if (ts.isFunctionDeclaration(node)) {
            const name = '_default';
            this.includeInContext(node, () => (Object.assign(Object.assign({}, this.getMethodSignature(node)), { name })));
            this.includeInContext(node, () => utils_1.getDefault(utils_1.getRef(name)));
        }
        else if (ts.isClassDeclaration(node)) {
            this.includeInContext(node, () => utils_1.getDefault(this.getClass(node)));
        }
        else {
            this.printWarning('default export', node);
        }
    }
    includeExportedFunction(node) {
        this.includeInContext(node, () => this.getFunctionDeclaration(node));
    }
    includeExportedClass(node) {
        this.includeInContext(node, () => this.getClass(node));
    }
    includeExportedInterface(node) {
        const name = this.getName(node, node.name.text);
        const exists = this.refs.some((m) => m.kind === 'interface' && m.name === name);
        if (!exists) {
            this.includeInContext(node, () => this.getInterface(node));
        }
        else {
            this.logVerbose(`Skipping already included interface "${name}".`);
        }
    }
    includeExportedVariable(node) {
        this.includeInContext(node, () => this.getVariable(node));
    }
    includeExportedVariables(node) {
        node.declarationList.declarations.forEach((decl) => this.includeExportedVariable(decl));
    }
    includeImportedValue(node) {
        const decl = node.symbol.declarations[0];
        this.enqueue(decl);
    }
    includeExportedEnum(node) {
        this.includeInContext(node, () => this.getEnum(node));
    }
    includeSelectedExports(elements) {
        // selected exports here
        elements.forEach((el) => {
            if (el.symbol) {
                const original = this.context.checker.getAliasedSymbol(el.symbol);
                if (original) {
                    const decl = helpers_1.getDeclarationFromSymbol(this.context.checker, original);
                    if (decl) {
                        this.processNode(decl);
                        this.swapName(original.name, el.symbol.name);
                    }
                }
                else if (el.propertyName) {
                    // renamed selected export
                    const symbol = this.context.checker.getExportSpecifierLocalTargetSymbol(el);
                    if (symbol) {
                        const decl = helpers_1.getDeclarationFromSymbol(this.context.checker, symbol);
                        if (decl) {
                            this.processNode(decl);
                            this.swapName(el.propertyName.text, el.symbol.name);
                        }
                    }
                }
            }
        });
    }
    includeStarExports(node) {
        var _a;
        if (node.moduleSpecifier && ts.isStringLiteral(node.moduleSpecifier)) {
            // * exports from a module
            const moduleName = node.moduleSpecifier.text;
            const modules = node.getSourceFile().resolvedModules;
            const fileName = (_a = modules === null || modules === void 0 ? void 0 : modules.get(moduleName)) === null || _a === void 0 ? void 0 : _a.resolvedFileName;
            if (fileName) {
                const newFile = this.context.program.getSourceFile(fileName);
                ts.forEachChild(newFile, (node) => {
                    if (helpers_1.shouldInclude(node)) {
                        this.enqueue(node);
                    }
                });
            }
        }
    }
    includeExportsDeclaration(node) {
        const { exportClause } = node;
        if (exportClause && ts.isNamedExports(exportClause) && exportClause.elements) {
            this.includeSelectedExports(exportClause.elements);
        }
        else {
            this.includeStarExports(node);
        }
    }
    processModule(node) {
        var _a;
        const c = this.context;
        const name = node.name.text;
        const availableImportNames = Object.keys(this.context.availableImports);
        c.modules[name] = this.refs = c.modules[name] || [];
        c.moduleNames[name] = this.names = c.moduleNames[name] || new Map();
        (_a = node.body) === null || _a === void 0 ? void 0 : _a.forEachChild((subNode) => {
            if (helpers_1.isNodeExported(subNode) || availableImportNames.includes(name)) {
                this.enqueue(subNode);
            }
        });
    }
    processNode(node) {
        if (ts.isTypeAliasDeclaration(node)) {
            this.includeExportedTypeAlias(node);
        }
        else if (helpers_1.isDefaultExport(node)) {
            this.includeDefaultExport(node);
        }
        else if (ts.isVariableDeclaration(node)) {
            this.includeExportedVariable(node);
        }
        else if (ts.isVariableStatement(node)) {
            this.includeExportedVariables(node);
        }
        else if (ts.isFunctionDeclaration(node)) {
            this.includeExportedFunction(node);
        }
        else if (ts.isInterfaceDeclaration(node)) {
            this.includeExportedInterface(node);
        }
        else if (ts.isClassDeclaration(node)) {
            this.includeExportedClass(node);
        }
        else if (ts.isImportSpecifier(node)) {
            this.includeImportedValue(node);
        }
        else if (ts.isEnumDeclaration(node)) {
            this.includeExportedEnum(node);
        }
        else if (ts.isTypeLiteralNode(node)) {
            // empty on purpose
            this.logVerbose(`Skipping type literal node: ${node}`);
        }
        else if (ts.isExportDeclaration(node)) {
            this.includeExportsDeclaration(node);
        }
        else if (ts.isModuleDeclaration(node)) {
            this.modules.push(node);
        }
        else if (ts.isImportTypeNode(node)) {
            // empty on purpose
            this.logVerbose(`Skipping import type node: ${node}`);
        }
        else {
            this.printWarning('type', node);
        }
    }
    enqueue(item) {
        if (!item) {
            // empty on purpose
        }
        else if (ts.isEnumMember(item)) {
            this.enqueue(item.parent);
        }
        else if (!this.queue.includes(item) && !this.processed.includes(item)) {
            this.queue.push(item);
        }
    }
    processQueue() {
        while (this.queue.length || this.modules.length) {
            while (this.queue.length > 0) {
                const item = this.queue.shift();
                this.processed.push(item);
                this.processNode(item);
            }
            if (this.modules.length > 0) {
                const mod = this.modules.shift();
                this.processModule(mod);
            }
        }
    }
}
exports.DeclVisitor = DeclVisitor;


/***/ }),

/***/ 203:
/***/ (function(__unusedmodule, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.getModifiers = exports.getSymbolName = exports.isGlobal = exports.fullyQualifiedName = void 0;
const typescript_1 = __webpack_require__(34);
const constants_1 = __webpack_require__(453);
const node_1 = __webpack_require__(427);
function fullyQualifiedName(symbol, delimiter) {
    const parts = [];
    do {
        parts.push(symbol.name);
        symbol = symbol.parent;
    } while (symbol && symbol.flags === typescript_1.SymbolFlags.NamespaceModule && symbol.name !== constants_1.globalIndicator);
    return parts.reverse().join(delimiter);
}
exports.fullyQualifiedName = fullyQualifiedName;
function isGlobal(symbol) {
    const parent = symbol === null || symbol === void 0 ? void 0 : symbol.parent;
    if (parent) {
        if (parent.name === constants_1.globalIndicator) {
            return true;
        }
        return isGlobal(parent);
    }
    return false;
}
exports.isGlobal = isGlobal;
function getSymbolName(symbol) {
    if (symbol.flags === typescript_1.SymbolFlags.EnumMember) {
        return `${symbol.parent.name}.${symbol.name}`;
    }
    return symbol.name;
}
exports.getSymbolName = getSymbolName;
function getModifiers(symbol) {
    var _a, _b, _c;
    const decorators = [];
    if (symbol) {
        const modifiers = (_c = (_b = (_a = symbol.declarations) === null || _a === void 0 ? void 0 : _a[0]) === null || _b === void 0 ? void 0 : _b.modifiers) !== null && _c !== void 0 ? _c : [];
        modifiers.some(node_1.isPrivate) && decorators.push('private');
        modifiers.some(node_1.isProtected) && decorators.push('protected');
        modifiers.some(node_1.isStatic) && decorators.push('static');
        modifiers.some(node_1.isReadonly) && decorators.push('readonly');
    }
    return decorators.join(' ');
}
exports.getModifiers = getModifiers;


/***/ }),

/***/ 247:
/***/ (function(__unusedmodule, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.includeApi = void 0;
const typescript_1 = __webpack_require__(34);
function includeApi(context, node, interfaceName) {
    if (typescript_1.isInterfaceDeclaration(node) && node.name.text === interfaceName) {
        context.exports.push(node);
    }
    else {
        context.log.verbose(`Skipping API using interface "${interfaceName}" from node: ${node}`);
    }
}
exports.includeApi = includeApi;


/***/ }),

/***/ 276:
/***/ (function(__unusedmodule, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.getPackage = exports.isImportedFile = exports.getRef = exports.getDefault = exports.createBinding = void 0;
const helpers_1 = __webpack_require__(361);
function createBinding(context, lib, name) {
    // if we did not use the given lib yet, add it to the used libs
    if (!context.usedImports.includes(lib)) {
        context.usedImports.push(lib);
    }
    return `${helpers_1.getLibRefName(lib)}.${name}`;
}
exports.createBinding = createBinding;
function getDefault(value) {
    return {
        kind: 'default',
        name: 'default',
        value,
    };
}
exports.getDefault = getDefault;
function getRef(refName, types = []) {
    return {
        kind: 'ref',
        refName,
        types,
    };
}
exports.getRef = getRef;
function getSymbolName(imports, node) {
    if (imports) {
        for (const name of Object.keys(imports)) {
            if (imports[name] === node) {
                return name;
            }
        }
    }
    return undefined;
}
function isImportedFile(node, root, imports) {
    var _a;
    const fn = (_a = node.getSourceFile()) === null || _a === void 0 ? void 0 : _a.fileName;
    if (fn) {
        const libName = helpers_1.getLibName(fn, root);
        return Object.keys(imports).some((name) => name === libName);
    }
    return false;
}
exports.isImportedFile = isImportedFile;
function getPackage(node, global, root, imports) {
    var _a;
    const fn = (_a = node.getSourceFile()) === null || _a === void 0 ? void 0 : _a.fileName;
    const base = helpers_1.isBaseLib(fn) || false;
    if (!base) {
        const libName = helpers_1.getLibName(fn, root);
        const [lib] = Object.keys(imports).filter((name) => {
            if (global) {
                return name === libName;
            }
            else {
                return Object.values(imports[name]).includes(node);
            }
        });
        const symbolName = getSymbolName(imports[lib], node);
        return {
            external: !!lib,
            moduleName: (lib && helpers_1.getModule(node)) || lib,
            symbolName,
            base,
            lib,
            fn,
        };
    }
    return {
        external: true,
        moduleName: undefined,
        symbolName: undefined,
        base,
        lib: undefined,
        fn,
    };
}
exports.getPackage = getPackage;


/***/ }),

/***/ 325:
/***/ (function(__unusedmodule, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.retrieveTypings = exports.generateDeclaration = exports.createExcludePlugin = exports.processVisitorContext = exports.addAmbientModules = exports.addAvailableImports = exports.fillExportsFromTypes = exports.fillExportsFromApi = exports.setupVisitorContext = void 0;
const ts = __webpack_require__(34);
const input_1 = __webpack_require__(342);
const output_1 = __webpack_require__(526);
const helpers_1 = __webpack_require__(361);
const logger_1 = __webpack_require__(906);
function setupVisitorContext(name, root, files, imports, log, flags) {
    const rootNames = files.filter((m) => !!m);
    const program = ts.createProgram(rootNames, {
        allowJs: true,
        esModuleInterop: true,
        module: ts.ModuleKind.ESNext,
        moduleResolution: ts.ModuleResolutionKind.NodeJs,
        jsx: ts.JsxEmit.React,
    });
    const checker = program.getTypeChecker();
    const context = {
        modules: {
            [name]: [],
        },
        moduleNames: {
            [name]: new Map(),
        },
        availableImports: {},
        usedImports: [],
        exports: [],
        root,
        checker,
        program,
        log,
        flags,
    };
    addAvailableImports(context, imports);
    addAmbientModules(context, imports);
    return context;
}
exports.setupVisitorContext = setupVisitorContext;
function fillExportsFromApi(context, apiPath, apiName) {
    const api = context.program.getSourceFile(apiPath);
    if (api) {
        ts.forEachChild(api, (node) => input_1.includeApi(context, node, apiName));
    }
    else {
        context.log.error(`Cannot find the "${apiPath}" module. Are you sure it exists? Please run "npm i" to install missing modules.`);
    }
}
exports.fillExportsFromApi = fillExportsFromApi;
function fillExportsFromTypes(context, typingsPath) {
    const tp = context.program.getSourceFile(typingsPath);
    if (tp) {
        ts.forEachChild(tp, (node) => input_1.includeTypings(context, node));
    }
    else {
        context.log.warn('Cannot find the provided typings. Check the "typings" field of your "package.json" for the correct path.');
    }
}
exports.fillExportsFromTypes = fillExportsFromTypes;
function addAvailableImports(context, imports) {
    var _a;
    const sourceFiles = context.program.getSourceFiles();
    const remaining = [...imports];
    context.log.verbose(`Adding ${imports.length} imports from ${sourceFiles.length} source files.`);
    for (const sourceFile of sourceFiles) {
        if (remaining.length === 0) {
            break;
        }
        (_a = sourceFile.resolvedModules) === null || _a === void 0 ? void 0 : _a.forEach((value, key) => {
            const index = remaining.indexOf(key);
            const fileName = value === null || value === void 0 ? void 0 : value.resolvedFileName;
            if (!fileName) {
                context.log.verbose(`Skipping module without filename: ${value}.`);
            }
            else if (index === -1) {
                context.log.verbose(`Skipping module "${fileName}" as it does not match.`);
            }
            else {
                const file = context.program.getSourceFile(fileName);
                input_1.includeExports(context, key, file === null || file === void 0 ? void 0 : file.symbol);
                remaining.splice(index, 1);
            }
        });
    }
}
exports.addAvailableImports = addAvailableImports;
function addAmbientModules(context, imports) {
    var _a, _b, _c;
    const modules = context.checker.getAmbientModules();
    context.log.verbose(`Adding ${modules.length} ambient modules.`);
    for (const module of modules) {
        const file = (_c = (_b = (_a = module.declarations) === null || _a === void 0 ? void 0 : _a[0]) === null || _b === void 0 ? void 0 : _b.getSourceFile()) === null || _c === void 0 ? void 0 : _c.fileName;
        const lib = helpers_1.getLibName(file, context.root);
        if (imports.includes(lib)) {
            input_1.includeExports(context, module.name, module);
        }
    }
}
exports.addAmbientModules = addAmbientModules;
function runAll(context, plugins, type) {
    const { log } = context;
    log.verbose(`Running the ${type}" plugins.`);
    plugins
        .filter((p) => p.type === type)
        .forEach((p) => {
        try {
            p.run(context);
        }
        catch (ex) {
            log.error(`The plugin "${p.name}" crashed: ${ex}`);
        }
    });
}
function processVisitorContext(context, plugins) {
    const { log } = context;
    runAll(context, plugins, 'before-init');
    const visitor = new input_1.DeclVisitor(context);
    runAll(context, plugins, 'before-process');
    log.verbose('Processing the queue.');
    visitor.processQueue();
    runAll(context, plugins, 'after-process');
    runAll(context, plugins, 'before-stringify');
    log.verbose('Generating the string representation.');
}
exports.processVisitorContext = processVisitorContext;
function createExcludePlugin(moduleNames) {
    return {
        type: 'after-process',
        name: 'exclude-plugin',
        run(context) {
            for (const name of moduleNames) {
                delete context.modules[name];
            }
        },
    };
}
exports.createExcludePlugin = createExcludePlugin;
function generateDeclaration(options) {
    const { name, root = process.cwd(), imports = [], files = [], types = [], apis = [], plugins = [], logger = logger_1.defaultLogger, logLevel = 3, noIgnore = false, } = options;
    const log = logger_1.wrapLogger(logger, logLevel);
    log.verbose(`Aggregating the sources from "${root}".`);
    const sources = [
        ...files.map((file) => helpers_1.findAppRoot(root, file)),
        ...apis.map((api) => helpers_1.findAppRoot(root, api.file)),
        ...types.map((type) => helpers_1.findAppRoot(root, type)),
    ];
    log.verbose(`Setting up a visitor context for "${name}".`);
    const context = setupVisitorContext(name, root, sources, imports, log, {
        noIgnore,
    });
    log.verbose(`Starting API gathering in "${root}".`);
    for (const api of apis) {
        const path = helpers_1.findAppRoot(root, api.file);
        fillExportsFromApi(context, path, api.name);
    }
    log.verbose(`Starting type aggregation from "${root}".`);
    for (const type of types) {
        const path = helpers_1.findAppRoot(root, type);
        fillExportsFromTypes(context, path);
    }
    log.verbose(`Processing the visitor context.`);
    processVisitorContext(context, plugins);
    return output_1.stringifyDeclaration(context);
}
exports.generateDeclaration = generateDeclaration;
function retrieveTypings(options) {
    const name = 'main';
    const { root = process.cwd(), imports = [], files = [], types = [], plugins = [], logger = logger_1.defaultLogger, logLevel = 3, noIgnore = false, } = options;
    const log = logger_1.wrapLogger(logger, logLevel);
    log.verbose(`Aggregating the sources from "${root}".`);
    const sources = [...files.map((file) => helpers_1.findAppRoot(root, file)), ...types.map((type) => helpers_1.findAppRoot(root, type))];
    log.verbose(`Setting up a visitor context for "${name}".`);
    const context = setupVisitorContext(name, root, sources, imports, log, {
        noIgnore,
    });
    log.verbose(`Starting type aggregation from "${root}".`);
    for (const type of types) {
        const path = helpers_1.findAppRoot(root, type);
        fillExportsFromTypes(context, path);
    }
    log.verbose(`Processing the visitor context.`);
    processVisitorContext(context, plugins);
    return context.modules.main;
}
exports.retrieveTypings = retrieveTypings;


/***/ }),

/***/ 342:
/***/ (function(__unusedmodule, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
__exportStar(__webpack_require__(247), exports);
__exportStar(__webpack_require__(777), exports);
__exportStar(__webpack_require__(72), exports);
__exportStar(__webpack_require__(33), exports);


/***/ }),

/***/ 361:
/***/ (function(__unusedmodule, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
__exportStar(__webpack_require__(754), exports);
__exportStar(__webpack_require__(367), exports);
__exportStar(__webpack_require__(427), exports);
__exportStar(__webpack_require__(688), exports);
__exportStar(__webpack_require__(672), exports);
__exportStar(__webpack_require__(203), exports);


/***/ }),

/***/ 367:
/***/ (function(__unusedmodule, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.getGlobalName = exports.getKeyName = exports.getLibName = exports.getParameterName = exports.getParameterElement = exports.getPropName = exports.getExportName = exports.getPredicateName = exports.getTypeRefName = exports.getLibRefName = exports.isAnonymous = void 0;
const typescript_1 = __webpack_require__(34);
const path_1 = __webpack_require__(622);
const constants_1 = __webpack_require__(453);
function isAnonymous(name) {
    return name === constants_1.anonymousIndicator;
}
exports.isAnonymous = isAnonymous;
function getLibRefName(libName) {
    if (libName[0] === '@') {
        libName = libName.substring(1);
    }
    const parts = libName.split(/[\/\-]/g);
    return parts.map(p => p[0].toUpperCase() + p.substring(1)).join('');
}
exports.getLibRefName = getLibRefName;
function getTypeRefName(name) {
    if (typescript_1.isIdentifier(name)) {
        return name.text;
    }
    else {
        // must be isQualifiedName(name)
        const ns = getTypeRefName(name.left);
        return `${ns}.${name.right.text}`;
    }
}
exports.getTypeRefName = getTypeRefName;
function getPredicateName(name) {
    if (typescript_1.isIdentifier(name)) {
        return name.text;
    } /* is ThisTypeNode */
    else {
        return 'this';
    }
}
exports.getPredicateName = getPredicateName;
function getExportName(name) {
    if (!name) {
        return undefined;
    }
    else if (typescript_1.isIdentifier(name)) {
        return name.text;
    }
    else if (typescript_1.isStringLiteral(name)) {
        return name.text;
    } /* is NumericLiteral */
    else {
        return name.text;
    }
}
exports.getExportName = getExportName;
function getPropName(name) {
    if (!name) {
        return undefined;
    }
    else if (typescript_1.isIdentifier(name)) {
        return name.text;
    }
    else if (typescript_1.isStringLiteral(name)) {
        return name.text;
    }
    else if (typescript_1.isNumericLiteral(name)) {
        return name.text;
    } /* isComputedPropertyName(name) */
    else {
        return name.getText();
    }
}
exports.getPropName = getPropName;
function getParameterElement(element) {
    return typescript_1.isBindingElement(element) ? getParameterName(element.name) : getParameterName(element);
}
exports.getParameterElement = getParameterElement;
function getParameterName(name) {
    if (typescript_1.isIdentifier(name)) {
        return name.text;
    }
    else if (typescript_1.isObjectBindingPattern(name)) {
        const content = name.elements.map(getParameterElement).join(', ');
        return `{ ${content} }`;
    }
    else if (typescript_1.isArrayBindingPattern(name)) {
        const content = name.elements.map(getParameterElement).join(', ');
        return `[${content}]`;
    } /* is OmittedExpression */
    else {
        return '';
    }
}
exports.getParameterName = getParameterName;
function makeModule(fileName, root) {
    const relFile = path_1.relative(root, fileName);
    const ext = path_1.extname(fileName);
    const file = !relFile.startsWith('.') ? `./${relFile}` : relFile;
    return file.substring(0, file.length - ext.length);
}
function getLibName(fileName, root) {
    if (fileName) {
        if (fileName.indexOf(constants_1.typesRoot) !== -1) {
            const start = fileName.lastIndexOf(constants_1.typesRoot) + constants_1.typesRoot.length;
            const name = fileName
                .substring(start)
                .split('/')
                .shift();
            if (name.indexOf('__') !== -1) {
                const [scope, lib] = name.split('__');
                return `@${scope}/${lib}`;
            }
            return name;
        }
        else if (fileName.indexOf(constants_1.modulesRoot) !== -1) {
            const start = fileName.lastIndexOf(constants_1.modulesRoot) + constants_1.modulesRoot.length;
            const [scope, lib] = fileName.substring(start).split('/');
            if (scope.indexOf('@') === 0) {
                return `${scope}/${lib}`;
            }
            return scope;
        }
        else {
            return makeModule(fileName, root);
        }
    }
    return undefined;
}
exports.getLibName = getLibName;
function getKeyName(info) {
    var _a, _b, _c, _d;
    return (_d = (_c = (_b = (_a = info === null || info === void 0 ? void 0 : info.declaration) === null || _a === void 0 ? void 0 : _a.parameters) === null || _b === void 0 ? void 0 : _b[0].name) === null || _c === void 0 ? void 0 : _c.text) !== null && _d !== void 0 ? _d : 'index';
}
exports.getKeyName = getKeyName;
function getGlobalName(symbol) {
    const { parent, name } = symbol;
    if (parent.name !== constants_1.globalIndicator) {
        return `${getGlobalName(parent)}.${name}`;
    }
    return name;
}
exports.getGlobalName = getGlobalName;


/***/ }),

/***/ 376:
/***/ (function(__unusedmodule, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.stringifyExports = exports.stringifyExport = void 0;
const stringify_1 = __webpack_require__(392);
function stringifyExport(type) {
    switch (type === null || type === void 0 ? void 0 : type.kind) {
        case 'interface':
            return `${stringify_1.stringifyComment(type)}export interface ${type.name}${stringify_1.stringifyTypeArgs(type)}${stringify_1.stringifyExtends(type)} ${stringify_1.stringifyInterface(type)}`;
        case 'class':
            return `${stringify_1.stringifyComment(type)}export class ${type.name}${stringify_1.stringifyTypeArgs(type)}${stringify_1.stringifyExtends(type)}${stringify_1.stringifyImplements(type)} ${stringify_1.stringifyClass(type)}`;
        case 'alias':
            return `${stringify_1.stringifyComment(type)}export type ${type.name}${stringify_1.stringifyTypeArgs(type)} = ${stringify_1.stringifyNode(type.child)};`;
        case 'enumLiteral':
            return `${stringify_1.stringifyComment(type)}export ${type.const ? 'const enum' : 'enum'} ${type.name} ${stringify_1.stringifyEnum(type.values)}`;
        case 'const':
            return `${stringify_1.stringifyComment(type)}export const ${type.name}: ${stringify_1.stringifyNode(type.value)};`;
        case 'function':
            return `${stringify_1.stringifyComment(type)}export function ${type.name}${stringify_1.stringifySignature(type, 1 /* property */)};`;
        case 'default':
            const sc = type.value.kind === 'class' ? '' : ';';
            return `${stringify_1.stringifyComment(type)}export default ${stringify_1.stringifyNode(type.value)}${sc}`;
    }
    return '';
}
exports.stringifyExport = stringifyExport;
function stringifyExports(refs) {
    return refs
        .map((r) => stringifyExport(r))
        .filter((m) => !!m)
        .join('\n\n');
}
exports.stringifyExports = stringifyExports;


/***/ }),

/***/ 392:
/***/ (function(__unusedmodule, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.stringifyNode = exports.stringifyReadonly = exports.stringifyPredicate = exports.stringifyGetAccessor = exports.stringifySetAccessor = exports.stringifyMember = exports.stringifyTernary = exports.stringifyTypeParameter = exports.stringifyTypeArgs = exports.stringifyTypes = exports.stringifyImplements = exports.stringifyExtends = exports.stringifyEnum = exports.stringifyClass = exports.stringifyInterface = exports.stringifyIndexedAccess = exports.stringifyMapped = exports.stringifyIndex = exports.stringifyConstructor = exports.stringifySignature = exports.stringifyParameters = exports.stringifyParameter = exports.stringifyProp = exports.stringifyComment = void 0;
const helpers_1 = __webpack_require__(361);
function stringifyComment(type) {
    if (type.comment) {
        const lines = type.comment
            .split('\n')
            .map((line) => ` * ${line}\n`)
            .join('');
        return `/**\n${lines} */\n`;
    }
    return '';
}
exports.stringifyComment = stringifyComment;
function stringifyProp(type) {
    const target = type.valueType;
    const comment = stringifyComment(type);
    const isOpt = type.optional ? '?' : '';
    const modifier = type.modifiers ? `${type.modifiers} ` : '';
    const name = helpers_1.makeIdentifier(type.name);
    if (typeof target === 'undefined') {
        return `${comment}${modifier}${name}${isOpt}: any`;
    }
    else if (target.kind === 'function') {
        return `${comment}${modifier}${name}${isOpt}${stringifySignature(target, 1 /* property */)}`;
    }
    else {
        return `${comment}${modifier}${name}${isOpt}: ${stringifyNode(target)}`;
    }
}
exports.stringifyProp = stringifyProp;
function stringifyParameter(param) {
    const isOpt = param.optional ? '?' : '';
    const spread = param.spread ? '...' : '';
    const modifiers = param.modifiers ? `${param.modifiers} ` : '';
    return `${modifiers}${spread}${param.param}${isOpt}: ${stringifyNode(param.value)}`;
}
exports.stringifyParameter = stringifyParameter;
function stringifyParameters(params) {
    return params.map(stringifyParameter).join(', ');
}
exports.stringifyParameters = stringifyParameters;
function stringifySignature(type, mode) {
    const ctor = type.kind === 'new' ? 'new ' : '';
    const prop = (mode & 1 /* property */) !== 0;
    const paren = (mode & 2 /* parenthesis */) !== 0;
    const parameters = stringifyParameters(type.parameters);
    const ta = stringifyTypeArgs(type);
    const rt = stringifyNode(type.returnType);
    const del = prop ? ': ' : ' => ';
    const result = `${ctor}${ta}(${parameters})${del}${rt}`;
    return paren ? `(${result})` : result;
}
exports.stringifySignature = stringifySignature;
function stringifyConstructor(type) {
    const parameters = stringifyParameters(type.parameters);
    return `constructor(${parameters})`;
}
exports.stringifyConstructor = stringifyConstructor;
function stringifyIndex(type) {
    const isOpt = type.optional ? '?' : '';
    const index = stringifyParameters(type.parameters);
    return `[${index}]${isOpt}: ${stringifyNode(type.valueType)}`;
}
exports.stringifyIndex = stringifyIndex;
function stringifyMapped(type) {
    const isOpt = type.optional ? '?' : '';
    const index = `${type.name} in ${stringifyNode(type.constraint)}`;
    return `[${index}]${isOpt}: ${stringifyNode(type.value)}`;
}
exports.stringifyMapped = stringifyMapped;
function stringifyIndexedAccess(type) {
    const front = stringifyNode(type.index);
    const back = stringifyNode(type.object);
    return `${back}[${front}]`;
}
exports.stringifyIndexedAccess = stringifyIndexedAccess;
function stringifyInterface(type) {
    const lines = type.props.map((p) => stringifyNode(p, 1 /* property */));
    if (type.mapped) {
        lines.push(stringifyMapped(type.mapped));
    }
    return helpers_1.toBlock(lines, ';');
}
exports.stringifyInterface = stringifyInterface;
function stringifyClass(type) {
    const lines = type.props.map((p) => stringifyNode(p));
    return helpers_1.toBlock(lines, ';');
}
exports.stringifyClass = stringifyClass;
function stringifyEnum(values) {
    const lines = values.map((p) => stringifyNode(p));
    return helpers_1.toBlock(lines, ',');
}
exports.stringifyEnum = stringifyEnum;
function stringifyExtends(type) {
    const { extends: es } = type;
    return es.length ? ` extends ${es.map((t) => stringifyNode(t)).join(', ')}` : '';
}
exports.stringifyExtends = stringifyExtends;
function stringifyImplements(type) {
    const { implements: is } = type;
    return is.length ? ` implements ${is.map((t) => stringifyNode(t)).join(', ')}` : '';
}
exports.stringifyImplements = stringifyImplements;
function stringifyTypes(types) {
    return types.map((t) => stringifyNode(t)).join(', ');
}
exports.stringifyTypes = stringifyTypes;
function stringifyTypeArgs(type) {
    var _a;
    if (((_a = type.types) === null || _a === void 0 ? void 0 : _a.length) > 0) {
        return `<${stringifyTypes(type.types)}>`;
    }
    return '';
}
exports.stringifyTypeArgs = stringifyTypeArgs;
function stringifyTypeParameter(type) {
    const name = stringifyNode(type.parameter);
    const constraint = stringifyNode(type.constraint);
    const defaults = stringifyNode(type.default);
    const constraintClause = constraint ? ` extends ${constraint}` : '';
    const defaultsClause = defaults ? ` = ${defaults}` : '';
    return `${name}${constraintClause}${defaultsClause}`;
}
exports.stringifyTypeParameter = stringifyTypeParameter;
function stringifyTernary(condition) {
    const t = stringifyNode(condition.check);
    const e = stringifyNode(condition.extends);
    const p = stringifyNode(condition.primary);
    const a = stringifyNode(condition.alternate);
    return `${t} extends ${e} ? ${p} : ${a}`;
}
exports.stringifyTernary = stringifyTernary;
function stringifyMember(member) {
    const name = `${stringifyComment(member)}${member.name}`;
    if (member.value) {
        return `${name} = ${stringifyNode(member.value)}`;
    }
    return name;
}
exports.stringifyMember = stringifyMember;
function stringifySetAccessor(accessor) {
    const comment = stringifyComment(accessor);
    const modifier = accessor.modifiers ? `${accessor.modifiers} ` : '';
    const args = stringifyParameters(accessor.parameters);
    return `${comment}${modifier}set ${accessor.name}(${args})`;
}
exports.stringifySetAccessor = stringifySetAccessor;
function stringifyGetAccessor(accessor) {
    const comment = stringifyComment(accessor);
    const modifier = accessor.modifiers ? `${accessor.modifiers} ` : '';
    const result = stringifyNode(accessor.type);
    return `${comment}${modifier}get ${accessor.name}(): ${result}`;
}
exports.stringifyGetAccessor = stringifyGetAccessor;
function stringifyPredicate(predicate) {
    const type = stringifyNode(predicate.value);
    return `${predicate.name} is ${type}`;
}
exports.stringifyPredicate = stringifyPredicate;
function stringifyReadonly(type) {
    const value = type.value;
    if (value.kind === 'ref' && value.refName === 'Array' && value.types.length === 1) {
        const [arg] = value.types;
        return `readonly ${stringifyNode(arg)}[]`;
    }
    return `readonly ${stringifyNode(value)}`;
}
exports.stringifyReadonly = stringifyReadonly;
function stringifyNode(type, mode = 0 /* default */) {
    switch (type === null || type === void 0 ? void 0 : type.kind) {
        case 'interface':
            return stringifyInterface(type);
        case 'prop':
            return stringifyProp(type);
        case 'ref':
            return `${type.refName}${stringifyTypeArgs(type)}`;
        case 'typeParameter':
            return stringifyTypeParameter(type);
        case 'union':
            return type.types.map((u) => stringifyNode(u, 2 /* parenthesis */)).join(' | ');
        case 'intersection':
            return type.types.map((u) => stringifyNode(u)).join(' & ');
        case 'member':
            return stringifyMember(type);
        case 'conditional':
            return stringifyTernary(type);
        case 'readonly':
            return stringifyReadonly(type);
        case 'unique':
            return `unique ${stringifyNode(type.value)}`;
        case 'keyof':
            return `keyof ${stringifyNode(type.value)}`;
        case 'infer':
            return `infer ${stringifyNode(type.parameter)}`;
        case 'any':
        case 'null':
        case 'void':
        case 'undefined':
        case 'boolean':
        case 'unknown':
        case 'bigint':
        case 'number':
        case 'never':
        case 'string':
            return type.kind;
        case 'nonPrimitive':
            return type.name || 'object';
        case 'esSymbol':
            return 'symbol';
        case 'unidentified':
            return 'any';
        case 'literal':
            return `${type.value}`;
        case 'indexedAccess':
            return stringifyIndexedAccess(type);
        case 'index':
            return stringifyIndex(type);
        case 'class':
            return `class ${stringifyClass(type)}`;
        case 'constructor':
            return stringifyConstructor(type);
        case 'mapped':
            return stringifyMapped(type);
        case 'substitution':
            return stringifyNode(type.variable);
        case 'rest':
            return `...${stringifyNode(type.value)}`;
        case 'new':
        case 'function':
            return stringifySignature(type, mode);
        case 'tuple':
            return `[${stringifyTypes(type.types)}]`;
        case 'set':
            return stringifySetAccessor(type);
        case 'get':
            return stringifyGetAccessor(type);
        case 'predicate':
            return stringifyPredicate(type);
        case 'template':
            return `\`${type.parts.map((p) => (typeof p === 'string' ? p : `\${${stringifyNode(p)}}`)).join('')}\``;
        case 'parenthesis':
            return `(${stringifyNode(type.value)})`;
    }
    return '';
}
exports.stringifyNode = stringifyNode;


/***/ }),

/***/ 427:
/***/ (function(__unusedmodule, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.isReadonly = exports.isProtected = exports.isStatic = exports.isPrivate = exports.isInferType = exports.isIdentifierType = exports.isUnionType = exports.isKeyOfType = exports.isNodeExported = exports.shouldInclude = exports.isDefaultExport = exports.getSymbol = exports.getDeclarationFromNode = exports.getDeclarationFromSymbol = exports.getModule = void 0;
const typescript_1 = __webpack_require__(34);
function getModule(node) {
    while (node) {
        // only string literal declared top-level modules are external modules
        if (typescript_1.isModuleDeclaration(node) && typescript_1.isSourceFile(node.parent) && typescript_1.isStringLiteral(node.name)) {
            return node.name.text;
        }
        node = node.parent;
    }
    return undefined;
}
exports.getModule = getModule;
function getDeclarationFromSymbol(checker, symbol) {
    var _a;
    if (!symbol) {
        return undefined;
    }
    else if (symbol.flags === typescript_1.SymbolFlags.Alias) {
        const aliasSymbol = checker.getAliasedSymbol(symbol);
        return getDeclarationFromSymbol(checker, aliasSymbol);
    }
    else {
        const decl = symbol.valueDeclaration || ((_a = symbol.declarations) === null || _a === void 0 ? void 0 : _a[0]);
        if (decl && typescript_1.isImportSpecifier(decl)) {
            return getDeclarationFromNode(checker, decl.name);
        }
        return decl;
    }
}
exports.getDeclarationFromSymbol = getDeclarationFromSymbol;
function getDeclarationFromNode(checker, node) {
    const symbol = getSymbol(checker, node);
    return getDeclarationFromSymbol(checker, symbol);
}
exports.getDeclarationFromNode = getDeclarationFromNode;
function getSymbol(checker, node) {
    var _a, _b, _c;
    const symbol = (_a = node.aliasSymbol) !== null && _a !== void 0 ? _a : node.symbol;
    if (symbol) {
        return symbol;
    }
    else if (typescript_1.isTypeReferenceNode(node)) {
        const ref = node.typeName;
        return (_c = (_b = ref.aliasSymbol) !== null && _b !== void 0 ? _b : ref.symbol) !== null && _c !== void 0 ? _c : checker.getSymbolAtLocation(ref);
    }
    else {
        return checker.getSymbolAtLocation(node);
    }
}
exports.getSymbol = getSymbol;
function isDefaultExport(node) {
    var _a;
    return ((_a = node.symbol) === null || _a === void 0 ? void 0 : _a.name) === 'default';
}
exports.isDefaultExport = isDefaultExport;
function shouldInclude(node) {
    return typescript_1.isModuleDeclaration(node) || typescript_1.isExportDeclaration(node) || isNodeExported(node);
}
exports.shouldInclude = shouldInclude;
function isNodeExported(node, alsoTopLevel = false) {
    return (typescript_1.isExportAssignment(node) ||
        (typescript_1.getCombinedModifierFlags(node) & typescript_1.ModifierFlags.Export) !== 0 ||
        (alsoTopLevel && !!node.parent && node.parent.kind === typescript_1.SyntaxKind.SourceFile));
}
exports.isNodeExported = isNodeExported;
function isKeyOfType(type) {
    return type && typescript_1.isTypeOperatorNode(type) && type.operator === typescript_1.SyntaxKind.KeyOfKeyword;
}
exports.isKeyOfType = isKeyOfType;
function isUnionType(type) {
    return type && typescript_1.isUnionTypeNode(type);
}
exports.isUnionType = isUnionType;
function isIdentifierType(type) {
    return type && typescript_1.isTypeReferenceNode(type) && typescript_1.isIdentifier(type.typeName);
}
exports.isIdentifierType = isIdentifierType;
function isInferType(type) {
    return type && typescript_1.isInferTypeNode(type);
}
exports.isInferType = isInferType;
function isPrivate(type) {
    return type.kind === typescript_1.SyntaxKind.PrivateKeyword;
}
exports.isPrivate = isPrivate;
function isStatic(type) {
    return type.kind === typescript_1.SyntaxKind.StaticKeyword;
}
exports.isStatic = isStatic;
function isProtected(type) {
    return type.kind === typescript_1.SyntaxKind.ProtectedKeyword;
}
exports.isProtected = isProtected;
function isReadonly(type) {
    return type.kind === typescript_1.SyntaxKind.ReadonlyKeyword;
}
exports.isReadonly = isReadonly;


/***/ }),

/***/ 453:
/***/ (function(__unusedmodule, exports) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.typesRoot = exports.modulesRoot = exports.anonymousIndicator = exports.globalIndicator = exports.globalFiles = exports.tslibPrefix = exports.tslibRoot = void 0;
exports.tslibRoot = '/node_modules/typescript/lib';
exports.tslibPrefix = 'lib.';
exports.globalFiles = ['globals.d.ts', 'global.d.ts'];
exports.globalIndicator = '__global';
exports.anonymousIndicator = '__type';
exports.modulesRoot = '/node_modules/';
exports.typesRoot = '/node_modules/@types/';


/***/ }),

/***/ 490:
/***/ (function(__unusedmodule, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.stringifyDeclaration = void 0;
const module_1 = __webpack_require__(51);
const helpers_1 = __webpack_require__(361);
function stringifyDeclaration(context) {
    const modules = Object.keys(context.modules)
        .filter(moduleName => Object.keys(context.modules[moduleName]).length > 0)
        .map(moduleName => module_1.stringifyModule(moduleName, context.modules[moduleName]))
        .join('\n\n');
    const preamble = context.usedImports.map(lib => `import * as ${helpers_1.getLibRefName(lib)} from '${lib}';`).join('\n');
    if (preamble) {
        return `${preamble}\n\n${modules}`;
    }
    return modules;
}
exports.stringifyDeclaration = stringifyDeclaration;


/***/ }),

/***/ 526:
/***/ (function(__unusedmodule, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
__exportStar(__webpack_require__(490), exports);
__exportStar(__webpack_require__(376), exports);
__exportStar(__webpack_require__(51), exports);


/***/ }),

/***/ 622:
/***/ (function(module) {

module.exports = require("path");

/***/ }),

/***/ 672:
/***/ (function(__unusedmodule, exports) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.toBlock = exports.toContent = exports.formatContent = exports.makeIdentifier = void 0;
// note that a valid identifier is more complicated than this,
// but let's keep it simple, which should be sufficient for most cases
const checkIdentifier = /^[a-zA-Z\_\$][a-zA-Z0-9\_\$]*$/;
function makeIdentifier(identifier) {
    return checkIdentifier.test(identifier) ? identifier : JSON.stringify(identifier);
}
exports.makeIdentifier = makeIdentifier;
function formatContent(content) {
    return content
        .split('\n')
        .map(line => (line ? `  ${line}\n` : '\n'))
        .join('');
}
exports.formatContent = formatContent;
function toContent(lines, terminator) {
    const content = lines.map(line => `${line}${terminator}`).join('\n');
    return formatContent(content);
}
exports.toContent = toContent;
function toBlock(lines, terminator) {
    if (lines.length > 0) {
        return `{\n${toContent(lines, terminator)}}`;
    }
    return '{}';
}
exports.toBlock = toBlock;


/***/ }),

/***/ 688:
/***/ (function(__unusedmodule, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.isBaseLib = exports.findAppRoot = void 0;
const path_1 = __webpack_require__(622);
const constants_1 = __webpack_require__(453);
function findAppRoot(root, app) {
    return path_1.resolve(root, app);
}
exports.findAppRoot = findAppRoot;
const pathCache = {};
function isBaseLib(path) {
    if (path in pathCache) {
        return pathCache[path];
    }
    else if (path) {
        const parts = path.split('/');
        const part = parts.pop();
        const newPath = parts.join('/');
        const result = (newPath.endsWith(constants_1.tslibRoot) && part.startsWith(constants_1.tslibPrefix)) || constants_1.globalFiles.includes(part);
        pathCache[path] = result;
        return result;
    }
    else {
        return false;
    }
}
exports.isBaseLib = isBaseLib;


/***/ }),

/***/ 695:
/***/ (function(__unusedmodule, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.includeProp = exports.includeClauses = void 0;
const ts = __webpack_require__(34);
const helpers_1 = __webpack_require__(361);
function includeClauses(context, clauses, newClause, tags = []) {
    var _a;
    const types = [];
    for (const clause of newClause.types) {
        const decl = helpers_1.getDeclarationFromNode(context.checker, clause.expression);
        const name = (_a = decl === null || decl === void 0 ? void 0 : decl.symbol) === null || _a === void 0 ? void 0 : _a.name;
        // check if we should remove the clause
        if (decl && !tags.some((m) => m.name === 'dets_removeclause' && m.text === name)) {
            types.push(clause);
        }
    }
    clauses.push(Object.assign(Object.assign({}, newClause), { types: ts.createNodeArray(types) }));
}
exports.includeClauses = includeClauses;
function includeProp(props, newProp, tags = []) {
    const name = helpers_1.getPropName(newProp.name);
    // check if we should remove the prop
    if (tags.some((m) => m.name === 'dets_removeprop' && m.text === name)) {
        return;
    }
    for (const oldProp of props) {
        if (oldProp.kind === newProp.kind && helpers_1.getPropName(oldProp.name) === name) {
            if (!ts.isMethodSignature(newProp)) {
                return;
            }
        }
    }
    props.push(newProp);
}
exports.includeProp = includeProp;


/***/ }),

/***/ 754:
/***/ (function(__unusedmodule, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.getComment = exports.getCommentOrDrop = exports.stringifyJsDocs = exports.getJsDocs = exports.getAllJsDocs = void 0;
const typescript_1 = __webpack_require__(34);
function isUnique(value, index, self) {
    return self.indexOf(value) === index;
}
function getAllJsDocs(checker, decls) {
    const allDocs = decls.map((decl) => getJsDocs(checker, decl));
    return {
        comment: allDocs
            .map((m) => m.comment)
            .reduce((p, c) => [...p, ...c], [])
            .filter(isUnique),
        tags: allDocs
            .map((m) => m.tags)
            .reduce((p, c) => [...p, ...c], [])
            .filter(isUnique),
    };
}
exports.getAllJsDocs = getAllJsDocs;
function getJsDocs(checker, node) {
    var _a, _b;
    if (typescript_1.isMethodDeclaration(node) || typescript_1.isMethodSignature(node)) {
        const sign = checker.getSignatureFromDeclaration(node);
        if (sign) {
            return {
                comment: sign.getDocumentationComment(checker),
                tags: sign.getJsDocTags(),
            };
        }
    }
    return {
        comment: (_a = node.symbol) === null || _a === void 0 ? void 0 : _a.getDocumentationComment(checker),
        tags: (_b = node.symbol) === null || _b === void 0 ? void 0 : _b.getJsDocTags(),
    };
}
exports.getJsDocs = getJsDocs;
const newLineTags = ['example'];
const removedTags = ['dets_removeprop', 'dets_removeclause', 'dets_preserve', 'dets_ignore'];
function stringifyJsDocTagText(txt) {
    if (typeof txt === 'string') {
        // quick fix for URLs (e.g., in React documentation), just remove first space
        if (txt.startsWith('http ://') || txt.startsWith('https ://')) {
            return txt.replace(' ', '');
        }
        return txt;
    }
    else if (Array.isArray(txt)) {
        return txt.map((s) => s.text).join('');
    }
    return '';
}
function stringifyJsDocs(doc) {
    const tags = (doc.tags || [])
        .filter((m) => !removedTags.includes(m.name))
        .map((m) => `@${m.name}${newLineTags.includes(m.name) ? '\n' : m.text ? ' ' : ''}${stringifyJsDocTagText(m.text)}`);
    const result = doc.comment ? doc.comment.map((m) => m.text) : [];
    if (tags) {
        result.push(...tags);
    }
    return result.join('\n');
}
exports.stringifyJsDocs = stringifyJsDocs;
function shouldDrop(canDrop, tags) {
    let found = false;
    if (tags) {
        for (const tag of tags) {
            switch (tag.name) {
                case 'ignore':
                    found = canDrop;
                    break;
                case 'dets_ignore':
                    return true;
                case 'dets_preserve':
                    return false;
            }
        }
    }
    return found;
}
function getCommentOrDrop(checker, node, canDrop = false) {
    const doc = getJsDocs(checker, node);
    if (shouldDrop(canDrop, doc.tags)) {
        return undefined;
    }
    return stringifyJsDocs(doc);
}
exports.getCommentOrDrop = getCommentOrDrop;
function getComment(checker, node) {
    const doc = getJsDocs(checker, node);
    return stringifyJsDocs(doc);
}
exports.getComment = getComment;


/***/ }),

/***/ 777:
/***/ (function(__unusedmodule, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.includeExports = void 0;
const ts = __webpack_require__(34);
const helpers_1 = __webpack_require__(361);
function includeExports(context, key, symbol) {
    const defs = {};
    if (symbol) {
        context.checker.getExportsOfModule(symbol).forEach((exp) => {
            var _a, _b, _c;
            const decl = exp.valueDeclaration || ((_a = exp.declarations) === null || _a === void 0 ? void 0 : _a[0]);
            if (!decl) {
                // skip - not really defined
            }
            else if (ts.isExportSpecifier(decl)) {
                const name = (_b = decl.name) === null || _b === void 0 ? void 0 : _b.text;
                if (name) {
                    defs[name] = helpers_1.getDeclarationFromNode(context.checker, decl);
                }
            }
            else if (ts.isExportAssignment(decl)) {
                defs['default'] = helpers_1.getDeclarationFromNode(context.checker, decl);
            }
            else if (ts.isVariableDeclaration(decl)) {
                defs[helpers_1.getParameterName(decl.name)] = decl;
            }
            else if (ts.isFunctionDeclaration(decl) ||
                ts.isInterfaceDeclaration(decl) ||
                ts.isClassDeclaration(decl) ||
                ts.isTypeAliasDeclaration(decl) ||
                ts.isEnumDeclaration(decl)) {
                const name = helpers_1.isDefaultExport(decl) ? 'default' : (_c = decl.name) === null || _c === void 0 ? void 0 : _c.text;
                if (name) {
                    defs[name] = decl;
                }
            }
            else if (ts.isMethodDeclaration(decl) || ts.isPropertyDeclaration(decl) || ts.isModuleDeclaration(decl)) {
                // skip - mostly from ambient modules
            }
            else if (ts.isImportEqualsDeclaration(decl)) {
                //skip - automatically "introduced"
            }
            else if (ts.isNamespaceExport(decl)) {
                defs[decl.name.text] = decl;
            }
            else {
                context.log.warn(`Skipping import of unknown node (kind: ${decl.kind}).`);
            }
        });
    }
    context.availableImports[key] = defs;
}
exports.includeExports = includeExports;


/***/ }),

/***/ 906:
/***/ (function(__unusedmodule, exports) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.wrapLogger = exports.defaultLogger = void 0;
exports.defaultLogger = {
    error(message) {
        throw new Error(message);
    },
    warn(message) {
        console.warn(message);
    },
    info(message) {
        console.info(message);
    },
    verbose(message) {
        console.log(message);
    },
};
const wrapLogger = (logger, level) => {
    return {
        error(message) {
            level >= 1 && logger.error(message);
        },
        warn(message) {
            level >= 2 && logger.warn(message);
        },
        info(message) {
            level >= 3 && logger.info(message);
        },
        verbose(message) {
            level >= 4 && logger.verbose(message);
        },
    };
};
exports.wrapLogger = wrapLogger;


/***/ })

/******/ });