"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.tryParseJson = exports.withoutKey = exports.withKey = exports.updateKey = exports.excludeOn = exports.removeNested = exports.replaceOrAddItem = exports.includeItem = exports.excludeItem = exports.appendItems = exports.prependItems = exports.appendItem = exports.prependItem = exports.noop = exports.none = exports.removeIndicator = void 0;
const tslib_1 = require("tslib");
// tslint:disable-next-line
exports.removeIndicator = null;
// to avoid creating unnecessary empty arrays
exports.none = [];
// to avoid creating unnecessary empty functions
const noop = () => { };
exports.noop = noop;
function prependItem(items, item) {
    return [item, ...(items || exports.none)];
}
exports.prependItem = prependItem;
function appendItem(items, item) {
    return [...(items || exports.none), item];
}
exports.appendItem = appendItem;
function prependItems(items, newItems) {
    return [...newItems, ...(items || exports.none)];
}
exports.prependItems = prependItems;
function appendItems(items, newItems) {
    return [...(items || exports.none), ...newItems];
}
exports.appendItems = appendItems;
function excludeItem(items, item) {
    return (items || exports.none).filter((m) => m !== item);
}
exports.excludeItem = excludeItem;
function includeItem(items, item) {
    return appendItem(excludeItem(items, item), item);
}
exports.includeItem = includeItem;
function replaceOrAddItem(items, item, predicate) {
    const newItems = [...(items || exports.none)];
    for (let i = 0; i < newItems.length; i++) {
        if (predicate(newItems[i])) {
            newItems[i] = item;
            return newItems;
        }
    }
    newItems.push(item);
    return newItems;
}
exports.replaceOrAddItem = replaceOrAddItem;
function removeNested(obj, predicate) {
    return Object.keys(obj).reduce((entries, key) => {
        const item = obj[key];
        entries[key] = Object.keys(item).reduce((all, key) => {
            const value = item[key];
            if (Array.isArray(value)) {
                all[key] = excludeOn(value, predicate);
            }
            else if (!value || !predicate(value)) {
                all[key] = value;
            }
            return all;
        }, {});
        return entries;
    }, {});
}
exports.removeNested = removeNested;
function excludeOn(items, predicate) {
    return (items || exports.none).filter((m) => !predicate(m));
}
exports.excludeOn = excludeOn;
function updateKey(obj, key, value) {
    return value === exports.removeIndicator ? withoutKey(obj, key) : withKey(obj, key, value);
}
exports.updateKey = updateKey;
function withKey(obj, key, value) {
    return Object.assign(Object.assign({}, obj), { [key]: value });
}
exports.withKey = withKey;
function withoutKey(obj, key) {
    const _a = obj || {}, _b = key, _ = _a[_b], newObj = (0, tslib_1.__rest)(_a, [typeof _b === "symbol" ? _b : _b + ""]);
    return newObj;
}
exports.withoutKey = withoutKey;
function tryParseJson(content) {
    try {
        return JSON.parse(content);
    }
    catch (_a) {
        return {};
    }
}
exports.tryParseJson = tryParseJson;
//# sourceMappingURL=helpers.js.map