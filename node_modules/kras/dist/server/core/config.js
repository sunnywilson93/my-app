"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.buildConfiguration = exports.defaultConfig = exports.mergeConfiguration = exports.readConfiguration = exports.makePathsAbsolute = void 0;
const path_1 = require("path");
const fs_1 = require("fs");
const info_1 = require("../info");
const chalk = require("chalk");
function makePathsAbsolute(baseDir, config) {
    if (config) {
        if (config.directory) {
            config.directory = path_1.resolve(baseDir, config.directory);
        }
        if (config.client) {
            config.client = path_1.resolve(baseDir, config.client);
        }
        if (config.injectors) {
            for (const name of Object.keys(config.injectors)) {
                const injector = config.injectors[name];
                const directory = injector.directory;
                if (typeof directory === 'string') {
                    injector.directory = path_1.resolve(baseDir, directory);
                }
                else if (Array.isArray(directory)) {
                    injector.directory = directory.map((dir) => path_1.resolve(baseDir, dir));
                }
            }
        }
    }
}
exports.makePathsAbsolute = makePathsAbsolute;
function readConfiguration(dir, file) {
    if (file) {
        const p = path_1.resolve(dir, file);
        if (fs_1.existsSync(p)) {
            try {
                const content = fs_1.readFileSync(p, 'utf8');
                const config = JSON.parse(content);
                if (config) {
                    makePathsAbsolute(dir, config);
                    return config;
                }
            }
            catch (e) {
                const msg = `Error reading configuration from ${file} in ${dir}: ${e}`;
                throw new Error(`${chalk.red('ERR')} ${chalk.white(msg)}`);
            }
        }
    }
    return {};
}
exports.readConfiguration = readConfiguration;
function mergeConfiguration(options, ...configs) {
    const config = Object.assign({}, ...configs);
    if (options) {
        if (options.cert !== undefined || options.key !== undefined) {
            config.ssl = {
                cert: options.cert || (config.ssl && config.ssl.cert),
                key: options.key || (config.ssl && config.ssl.key),
            };
        }
        if (options.skipApi) {
            config.api = false;
        }
        if (options.logs) {
            config.logLevel = options.logs;
        }
        if (options.dir) {
            config.directory = options.dir;
        }
        if (options.name) {
            config.name = options.name;
        }
        if (options.port) {
            config.port = options.port;
        }
    }
    return config;
}
exports.mergeConfiguration = mergeConfiguration;
exports.defaultConfig = {
    name: `${info_1.name} v${info_1.version}`,
    port: 9000,
    directory: path_1.resolve(info_1.currentDir, 'mocks'),
    client: 'kras-management-portal',
    ssl: {
        cert: path_1.resolve(info_1.rootDir, 'cert', 'server.crt'),
        key: path_1.resolve(info_1.rootDir, 'cert', 'server.key'),
    },
    uploadLimit: parseInt(process.env.FILE_SIZE_LIMIT, 10) || 10,
    logLevel: 'error',
    api: '/manage',
    ws: true,
    map: {
        '': 'https://httpbin.org',
        '/api': 'https://jsonplaceholder.typicode.com',
        '/events': 'ws://demos.kaazing.com/echo',
    },
    auth: undefined,
    middlewares: [],
    injectors: {
        script: {
            active: true,
        },
        har: {
            active: true,
            delay: false,
        },
        json: {
            active: true,
            randomize: true,
        },
        proxy: {
            active: true,
        },
        store: {
            active: false,
        },
    },
};
function buildConfiguration(config = {}) {
    const newConfig = Object.assign({}, exports.defaultConfig, config);
    const newMap = {};
    Object.keys(newConfig.map || {}).forEach((oldKey) => {
        const newKey = oldKey.replace(/\/+$/, '');
        newMap[newKey] = newConfig.map[oldKey];
    });
    newConfig.map = newMap;
    return newConfig;
}
exports.buildConfiguration = buildConfiguration;
