"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.WebServer = void 0;
const express = require("express");
const expressWs = require("express-ws");
const http_1 = require("http");
const https_1 = require("https");
const body_parser_1 = require("body-parser");
const multer = require("multer");
const events_1 = require("events");
const readSsl_1 = require("./readSsl");
const proxy_1 = require("./proxy");
function findHook(hooks, req) {
    let closest = undefined;
    let highscore = 0;
    for (const hook of hooks) {
        const score = hook.rate(req);
        if (score === 1) {
            return hook;
        }
        else if (score > highscore) {
            highscore = score;
            closest = hook;
        }
    }
    if (closest) {
        return closest;
    }
}
function getWsTargets(mapping) {
    const keys = Object.keys(mapping);
    if (keys.length) {
        const targets = keys.filter((key) => {
            const address = mapping[key];
            if (typeof address === 'string') {
                return address.match('^wss?://');
            }
            return address;
        });
        if (targets.length) {
            return targets;
        }
    }
    return ['*'];
}
class WebServer extends events_1.EventEmitter {
    constructor(config = {}) {
        super();
        this.hooks = [];
        this.routes = [];
        const mapping = config.map || {};
        const ssl = readSsl_1.readSsl(config.ssl);
        this.targets = getWsTargets(mapping);
        this.port = config.port || 9000;
        this.app = express();
        this.protocol = ssl ? 'https' : 'http';
        this.server = ssl ? https_1.createServer(ssl, this.app) : http_1.createServer(this.app);
        this.wsOptions = typeof config.ws === 'object' ? config.ws : undefined;
        this.ws = !!config.ws;
        const sizeInMB = typeof config.uploadLimit === 'number' ? config.uploadLimit : 10;
        const upload = multer({
            storage: multer.memoryStorage(),
            limits: { files: 5, fileSize: sizeInMB * 1024 * 1024 },
        });
        this.app.use(upload.any());
        this.app.use(body_parser_1.text({
            type: (req) => {
                return !(req.headers['content-type'] && req.headers['content-type'].search('multipart/form-data') !== -1);
            },
            limit: '50mb',
        }));
        this.targets.forEach((target) => this.app.ws(target, (ws, req) => {
            const url = req.url.replace('/.websocket', '').substr(target.length);
            const id = Date.now() % 100000000;
            this.emit('user-connected', {
                id,
                ws,
                target,
                url,
                req,
            });
            ws.on('close', () => this.emit('user-disconnected', {
                id,
                ws,
                target,
                url,
                req,
            }));
        }));
    }
    get ws() {
        const ws = this.sockets && this.sockets.getWss();
        return !!ws;
    }
    set ws(value) {
        const ws = this.sockets && this.sockets.getWss();
        if (!value && ws) {
            this.emit('info', 'Turned off WebSocket support');
            ws.close();
            this.sockets = undefined;
        }
        else if (!ws && value) {
            this.emit('info', 'Turned on WebSocket support');
            this.sockets = expressWs(this.app, this.server, {
                wsOptions: this.wsOptions,
            });
            const wsServer = this.sockets.getWss();
            wsServer.on('connection', (socket) => {
                socket.on('error', (err) => {
                    this.emit('error', `Problem with the WS socket connection: ${err}`);
                });
            });
            wsServer.on('error', (err) => {
                this.emit('error', `Error with WS server: ${err}`);
            });
        }
    }
    add(hook) {
        if (Array.isArray(hook)) {
            this.hooks.push.apply(this.hooks, hook);
        }
        else if (typeof hook === 'object') {
            this.hooks.push(hook);
        }
        return this;
    }
    remove(hook) {
        const index = this.hooks.indexOf(hook);
        this.hooks.splice(index, 1);
        return this;
    }
    at(...segments) {
        const endpoint = segments.join('/');
        const app = this.app;
        const api = {
            get(handler) {
                app.get(endpoint, handler);
                return api;
            },
            put(handler) {
                app.put(endpoint, handler);
                return api;
            },
            delete(handler) {
                app.delete(endpoint, handler);
                return api;
            },
            post(handler) {
                app.post(endpoint, handler);
                return api;
            },
            any(handler) {
                app.all(endpoint, handler);
                return api;
            },
            feed(handler) {
                app.ws(endpoint, handler);
                return api;
            },
        };
        this.routes.push(endpoint);
        return api;
    }
    start() {
        this.app.all('*', (req, res) => {
            if (req.method !== 'OPTIONS') {
                const hook = findHook(this.hooks, req);
                if (!hook) {
                    res.status(404);
                    return res.end('Page could not be found.');
                }
                return hook.handle(req, res);
            }
            this.emit('debug', `Handled CORS request to ${req.url}`);
            return proxy_1.corsHandler(req, res);
        });
        return new Promise((resolve) => {
            this.server.listen(this.port, () => {
                this.emit('open', {
                    port: this.port,
                    protocol: this.protocol,
                    routes: this.routes,
                });
                resolve();
            });
        });
    }
    stop() {
        this.emit('close');
        return new Promise((resolve) => this.server.close(() => resolve()));
    }
    broadcast(msg) {
        const sockets = this.sockets;
        if (sockets) {
            const isObject = typeof msg === 'object';
            const data = isObject ? JSON.stringify(msg) : (msg || '').toString();
            const targets = this.targets;
            const wst = targets.length !== 1 || targets[0] !== '*' ? targets : undefined;
            this.emit('broadcast', { content: data, from: 'kras', to: '*', remote: false });
            const socket = sockets.getWss(wst);
            if (socket) {
                const clients = socket.clients;
                this.emit('debug', `Broadcasting to ${clients.size} client(s)`);
                clients.forEach((client) => client.send(data));
            }
        }
    }
}
exports.WebServer = WebServer;
