"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const WebSocket = require("ws");
const helpers_1 = require("../helpers");
function normalizeHeader(header) {
    return header.toLowerCase();
}
function releaseFrom(buffer, ws) {
    const item = buffer.shift();
    ws.send(item.data);
    if (buffer.length) {
        const diff = buffer[0].time - item.time;
        setTimeout(() => releaseFrom(buffer, ws), diff);
    }
}
function integrateXfwd(headers, protocol, req) {
    const values = {
        for: req.remoteAddress,
        port: req.port,
        proto: req.encrypted ? `${protocol}s` : protocol,
    };
    Object.keys(values).forEach((key) => {
        const forwardKey = `x-forwarded-${key}`;
        const forward = headers[forwardKey] || '';
        const sep = forward ? ',' : '';
        headers[forwardKey] = forward + sep + values[key];
    });
}
class ProxyInjector {
    constructor(options, config, core) {
        this.sessions = {};
        this.config = options;
        this.connectors = Object.keys(config.map)
            .filter((target) => config.map[target] !== false)
            .map((target) => ({
            target,
            address: config.map[target],
        }));
        this.core = core;
        core.on('user-connected', (e) => {
            const [target] = this.connectors.filter((m) => m.target === e.target);
            if (target) {
                let open = false;
                const url = target.address + e.url;
                const buffer = [];
                const headers = {};
                if (this.config.xfwd) {
                    const req = e.req;
                    integrateXfwd(headers, 'ws', {
                        remoteAddress: req.connection.remoteAddress || req.socket.remoteAddress,
                        port: helpers_1.getPort(req),
                        encrypted: helpers_1.isEncrypted(req),
                    });
                }
                const ws = new WebSocket(url, e.ws.protocol, {
                    rejectUnauthorized: false,
                    headers,
                });
                ws.on('error', (err) => core.emit('error', err));
                ws.on('open', () => {
                    open = true;
                    if (buffer.length) {
                        releaseFrom(buffer, ws);
                    }
                });
                ws.on('close', (e) => {
                    open = false;
                    core.emit('ws-closed', { reason: e });
                });
                ws.on('message', (data) => {
                    core.emit('message', { content: data, from: url, to: e.id, remote: true });
                    e.ws.send(data, (err) => core.emit('error', err));
                });
                e.ws.on('message', (data) => {
                    core.emit('message', { content: data, to: url, from: e.id, remote: false });
                    if (open) {
                        ws.send(data, (err) => core.emit('error', err));
                    }
                    else {
                        buffer.push({
                            time: Date.now(),
                            data,
                        });
                    }
                });
                this.sessions[e.id] = ws;
            }
        });
        core.on('user-disconnected', (e) => {
            const ws = this.sessions[e.id];
            ws && ws.close();
            delete this.sessions[e.id];
        });
    }
    getOptions() {
        const options = {};
        for (const { target, address } of this.connectors) {
            options[target] = {
                description: `Determines where to proxy to if local URL starts with "${target}".`,
                title: `Target: ${target}`,
                type: 'text',
                value: address,
            };
        }
        return options;
    }
    setOptions(options) {
        for (const item of this.connectors) {
            const address = options[item.target];
            if (address !== undefined) {
                item.address = address;
            }
        }
    }
    get name() {
        return 'proxy-injector';
    }
    get active() {
        return this.config.active;
    }
    set active(value) {
        this.config.active = value;
    }
    handle(req) {
        const defaultHeaders = (this.config.defaultHeaders || helpers_1.defaultProxyHeaders).map(normalizeHeader);
        const discardHeaders = (this.config.discardHeaders || []).map(normalizeHeader);
        const permitHeaders = (this.config.permitHeaders || []).map(normalizeHeader);
        const injectHeaders = this.config.injectHeaders || {};
        const headerNames = [
            ...defaultHeaders.filter((header) => !discardHeaders.includes(header)),
            ...permitHeaders,
            ...Object.keys(injectHeaders),
        ];
        const headers = headerNames.reduce((headers, header) => {
            var _a;
            headers[header] = (_a = injectHeaders[header]) !== null && _a !== void 0 ? _a : req.headers[header];
            return headers;
        }, {});
        const [target] = this.connectors.filter((m) => m.target === req.target);
        if (this.config.xfwd) {
            integrateXfwd(headers, 'http', req);
            headers['x-forwarded-host'] = headers['x-forwarded-host'] || headers.host || '';
        }
        if (target) {
            return new Promise((resolve) => helpers_1.proxyRequest({
                headers,
                url: target.address + req.url,
                method: req.method,
                body: req.content,
                agentOptions: this.config.agentOptions,
                proxy: this.config.proxy,
                injector: {
                    name: this.name,
                    host: target,
                },
                redirect: this.config.followRedirect,
            }, (err, ans) => {
                if (err) {
                    this.core.emit('error', err);
                }
                resolve(ans);
            }));
        }
    }
}
exports.default = ProxyInjector;
