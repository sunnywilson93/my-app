"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.JsonInjector = exports.StoreInjector = exports.HarInjector = exports.ProxyInjector = exports.ScriptInjector = exports.withInjectors = void 0;
const fs_1 = require("fs");
const path_1 = require("path");
const url_1 = require("url");
const helpers_1 = require("../helpers");
const info_1 = require("../info");
const FormData = require("form-data");
const har_injector_1 = require("./har-injector");
exports.HarInjector = har_injector_1.default;
const json_injector_1 = require("./json-injector");
exports.JsonInjector = json_injector_1.default;
const proxy_injector_1 = require("./proxy-injector");
exports.ProxyInjector = proxy_injector_1.default;
const script_injector_1 = require("./script-injector");
exports.ScriptInjector = script_injector_1.default;
const store_injector_1 = require("./store-injector");
exports.StoreInjector = store_injector_1.default;
const specialHeaders = ['origin', 'content-type'];
const coreInjectors = {
    har: har_injector_1.default,
    json: json_injector_1.default,
    proxy: proxy_injector_1.default,
    script: script_injector_1.default,
    store: store_injector_1.default,
};
function sendResponse(req, ans, res) {
    if (!ans.redirectUrl) {
        const origin = req.headers.origin;
        const type = ans.headers['content-type'];
        for (const headerName of Object.keys(ans.headers)) {
            if (specialHeaders.indexOf(headerName) === -1) {
                res.setHeader(headerName, ans.headers[headerName]);
            }
        }
        if (origin) {
            res.setHeader('Access-Control-Allow-Origin', origin);
        }
        res.setHeader('Access-Control-Allow-Credentials', 'true');
        res.status(ans.status.code);
        res.type(type);
        res.end(ans.content);
    }
    else {
        const target = url_1.parse(ans.redirectUrl);
        res.redirect(ans.status.code, target.path);
    }
}
function normalizeTarget(head) {
    return head.endsWith('/') ? head.substr(0, head.length - 1) : head;
}
function getTarget(targets, url) {
    for (const target of targets) {
        if (url.startsWith(target)) {
            const c = url[target.length];
            if (c === undefined || c === '?' || c === '/') {
                return target;
            }
        }
    }
    return undefined;
}
function normalizeRequest(targets, req) {
    const target = getTarget(targets, req.originalUrl) || '';
    const url = req.originalUrl.substr(target.length);
    const query = Object.assign({}, req.query);
    const headers = Object.assign({}, req.headers);
    let content;
    if (req.headers['content-type'] && req.headers['content-type'].search('multipart/form-data') !== -1) {
        const formData = new FormData();
        typeof req.body === 'object' &&
            Object.keys(req.body).map((field) => {
                return formData.append(field, req.body[field]);
            });
        req.files &&
            req.files.length &&
            Array.prototype.map.call(req.files, (file) => {
                return formData.append(file.fieldname, file.buffer, {
                    filename: file.originalname,
                });
            });
        headers['content-type'] = formData.getHeaders()['content-type'];
        content = formData;
    }
    else {
        content = typeof req.body === 'string' ? req.body : '';
    }
    const method = typeof req.method === 'string' ? req.method : 'GET';
    delete query._;
    return {
        url,
        encrypted: helpers_1.isEncrypted(req),
        port: helpers_1.getPort(req),
        remoteAddress: req.connection.remoteAddress || req.socket.remoteAddress,
        target,
        query,
        method,
        headers,
        content,
    };
}
function tryInjectors(injectors, req) {
    return __awaiter(this, void 0, void 0, function* () {
        if (injectors.length > 0) {
            const injector = injectors.shift();
            const { ignore, handle } = injector.config || { ignore: undefined, handle: undefined };
            const ignored = ignore && ignore.some((t) => normalizeTarget(t) === req.target);
            const handled = !handle || handle.some((t) => normalizeTarget(t) === req.target);
            const response = !ignored && handled && (yield injector.handle(req));
            return response || tryInjectors(injectors, req);
        }
        return undefined;
    });
}
function handleRequest(server, req, res) {
    const injectors = server.injectors.filter((injector) => injector.active);
    server.emit('request', req);
    tryInjectors(injectors, req).then((ans) => {
        if (!ans) {
            server.emit('missing', req);
            ans = helpers_1.fromMissing(req.url);
        }
        else {
            server.emit('response', ans);
        }
        sendResponse(req, ans, res);
    });
}
function findInjector(modulePath) {
    try {
        const { default: Injector } = require(modulePath);
        return Injector;
    }
    catch (e) {
        return undefined;
    }
}
function addInjectorInstance(Injector, options, config, server) {
    if (Injector) {
        const instance = new Injector(options, config, server);
        if (typeof instance.handle === 'function') {
            server.injectors.push(instance);
        }
    }
}
function withInjectors(server, config) {
    const names = Object.keys(config.injectors);
    const heads = Object.keys(config.map)
        .map((head) => normalizeTarget(head))
        .sort((a, b) => b.length - a.length);
    const ignored = Object.keys(config.map)
        .filter((head) => config.map[head] === false)
        .map((head) => normalizeTarget(head));
    const always = heads.length === 0;
    if (info_1.injectorDebug) {
        const Injector = findInjector(info_1.injectorMain);
        addInjectorInstance(Injector, info_1.injectorConfig, config, server);
    }
    for (const name of names) {
        const isPath = path_1.basename(name) !== name && fs_1.existsSync(name);
        const Injector = coreInjectors[name] ||
            (isPath && findInjector(name)) ||
            findInjector(path_1.resolve(config.directory, `${name}-injector`)) ||
            findInjector(`kras-${name}-injector`) ||
            findInjector(`${name}-kras-injector`) ||
            findInjector(`${name}-injector`) ||
            findInjector(path_1.resolve(process.cwd(), `${name}-injector`)) ||
            findInjector(path_1.resolve(__dirname, `${name}-injector`));
        addInjectorInstance(Injector, config.injectors[name], config, server);
    }
    server.add({
        rate: (req) => {
            if (!always) {
                const target = getTarget(heads, req.url);
                const hasTarget = target !== undefined;
                return hasTarget && !ignored.includes(target) ? 1 : 0;
            }
            return 1;
        },
        handle: (req, res) => {
            const entry = normalizeRequest(heads, req);
            return handleRequest(server, entry, res);
        },
    });
}
exports.withInjectors = withInjectors;
