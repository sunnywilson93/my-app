import * as Events from 'events';
import * as Express from 'express';
import * as Http from 'http';
import * as Url from 'url';
import * as Tls from 'tls';
import * as Https from 'https';
import * as Zlib from 'zlib';

declare module "kras" {
  export interface ConfigurationOptions {
    name?: string;
    port?: number;
    logs?: LogLevel;
    dir?: string;
    cert?: string;
    key?: string;
    skipApi?: boolean;
  }

  export interface ConfigurationFile {
    [key: string]: any;
  }

  export function makePathsAbsolute(baseDir: string, config: ConfigurationFile): void;

  export function readConfiguration(dir: string, file: string): ConfigurationFile;

  export function mergeConfiguration(options?: ConfigurationOptions, ...configs: Array<ConfigurationFile>): KrasConfiguration;

  export const defaultConfig: KrasConfiguration;

  export function buildConfiguration(config?: Partial<ConfigurationFile>): KrasConfiguration;

  export const rootDir: string;

  export const currentDir: string;

  export const krasrc: ".krasrc";

  export const author: string;

  export const name: string;

  export const version: string;

  export const injectorDebug: boolean;

  export const injectorConfig: any;

  export const injectorMain: string;

  export function withInjectors(server: KrasServer, config: KrasConfiguration): void;

  export class MockServer extends MockServerCore implements KrasServer {
    readonly injectors: Array<KrasInjector>;
    readonly middlewares: Array<KrasMiddleware>;
    readonly logs: Array<LogEntry>;
    readonly logLevel: LogLevel;
    constructor(config: KrasConfiguration);
    stop(): Promise<void>;
    private log(type: LogEntryType, data: any): void;
  }

  export function readKrasConfig(options?: ConfigurationOptions, file?: string): KrasConfiguration;

  export function buildKras(config?: Partial<KrasConfiguration>): MockServer;

  export function buildKrasWithCli(config: KrasConfiguration): MockServer;

  export function runKras(config?: Partial<KrasConfiguration>): MockServer;

  export type KrasRuntimeConfiguration = Partial<KrasConfiguration> & KrasHandlerConfiguration;

  export function withKras(config?: KrasRuntimeConfiguration): (callback: KrasRunner) => Promise<void>;

  export function runWithKras(cb: KrasRunner, config?: KrasRuntimeConfiguration): Promise<void>;

  export function connectToCli(server: MockServer, canManage?: boolean): void;

  export function runFromCli(options: ConfigurationOptions, rcfile: string): MockServer;

  export type LogLevel = "debug" | "info" | "error";

  export interface KrasConfiguration extends WebServerConfiguration {
    name: string;
    client: string;
    directory: string;
    sources?: Array<string>;
    api: string | false;
    auth: undefined | KrasAuth;
    middlewares: Array<KrasMiddlewareDefinition>;
    injectors: KrasConfigurationInjectors;
  }

  export interface KrasServer extends BaseKrasServer {
    readonly injectors: Array<KrasInjector>;
    readonly middlewares: Array<KrasMiddleware>;
    readonly recorder: KrasRecorder;
    readonly logs: Array<LogEntry>;
    readonly logLevel: LogLevel;
  }

  export interface KrasInjector {
    active: boolean;
    config: KrasInjectorConfig;
    readonly name: string;
    readonly handle: KrasRequestHandler;
    getOptions(): KrasInjectorOptions;
    setOptions(options: Dict<any>): void;
    dispose?(): void;
  }

  export interface ScriptFiles {
    [file: string]: ScriptFileEntry;
  }

  export interface Watcher {
    directories: Array<string>;
    close(): void;
  }

  export interface KrasInjectorConfig {
    /**
     * Determins if the injector is active.
     */
    active: boolean;
    /**
     * Optionally sets the targets to ignore.
     * Otherwise, no targets are ignored.
     */
    ignore?: Array<string>;
    /**
     * Optionally sets explicitly the targets to handle.
     * Otherwise, all targeta are handled.
     */
    handle?: Array<string>;
  }

  export interface ScriptInjectorConfig {
    directory?: string | Array<string>;
    extended?: ScriptContextData;
  }

  export type KrasInjectorOptions = Dict<KrasInjectorOption>;

  export interface DynamicScriptInjectorConfig {
    extended: string;
    directories: Array<string>;
    files: Array<{
      name: string;
      active: boolean;
    }>;
  }

  export interface KrasRequest extends BasicKrasRequest {
    encrypted: boolean;
    remoteAddress: string;
    port: string;
  }

  export interface KrasAnswer {
    headers: Headers;
    status: {
      code: number;
      text?: string;
    };
    url: string;
    redirectUrl?: string;
    content: string | Buffer;
    injector?: KrasInjectorInfo;
  }

  export interface WebSocketSessions {
    [id: string]: WebSocket;
  }

  export interface ProxyInjectorConfig {
    agentOptions?: any;
    proxy?: any;
    xfwd?: boolean;
    defaultHeaders?: Array<string>;
    discardHeaders?: Array<string>;
    permitHeaders?: Array<string>;
    injectHeaders?: Record<string, string>;
    followRedirect?: boolean;
  }

  export interface DynamicProxyInjectorConfig {
    [target: string]: string;
  }

  export interface HarFiles {
    [file: string]: Array<HarFileEntry>;
  }

  export interface HarInjectorConfig {
    directory?: string | Array<string>;
    delay?: boolean;
  }

  export interface DynamicHarInjectorConfig {
    delay: boolean;
    directories: Array<string>;
    files: Array<{
      name: string;
      entries: Array<{
        active: boolean;
      }>;
    }>;
  }

  export interface HttpArchive {
    active: boolean;
    request: HarRequest;
    response: HarResponse;
    time: number;
  }

  export type Headers = Dict<string>;

  export interface HarResponse {
    status: number;
    statusText: string;
    redirectURL: string;
    headers: HarHeaders;
    content: {
      encoding?: BufferEncoding;
      mimeType: string;
      text?: string;
    };
  }

  export class JsonStore<T> {
    constructor(file: string);
    insert(item: T): void;
    delete(predicate?: (item: T) => boolean): void;
    select(predicate?: (item: T) => boolean): Array<T>;
    switchTo(file: string): void;
  }

  export interface StoreRequestEntry {
    request: KrasRequest;
    response: {
      status: number;
    };
  }

  export interface StoreInjectorConfig {
    directory?: string;
    filename?: string;
  }

  export interface DynamicStoreInjectorConfig {
    file?: string;
  }

  export interface JsonFiles {
    [file: string]: Array<JsonFileItem>;
  }

  export interface JsonInjectorConfig {
    directory?: string | Array<string>;
    randomize?: boolean;
    generator?: boolean;
    generatorLocaleName?: string;
  }

  export interface DynamicJsonInjectorConfig {
    randomize: boolean;
    directories: Array<string>;
    files: Array<{
      name: string;
      entries: Array<{
        active: boolean;
      }>;
    }>;
  }

  export interface FileInfo {
    active: boolean;
    error?: string;
  }

  export interface DescribeEntry<T> {
    (item: T, file: string, index: number): string;
  }

  export function editDirectoryOption(directories: Array<string>): KrasInjectorOption;

  export function editFileOption(files: Dict<FileInfo>): KrasInjectorOption;

  export function editEntryOption<T extends FileInfo>(files: Dict<Array<T>>, desc: DescribeEntry<T>): KrasInjectorOption;

  export type HarHeaders = Array<{
    name: string;
    value: string;
  }>;

  export interface HarRequest {
    url: string;
    method: string;
    target?: string;
    postData?: {
      text?: string;
    };
    headers: HarHeaders;
    queryString: HarHeaders;
  }

  export interface NodeResponse {
    headers: Dict<string | Array<string>>;
    statusCode: number;
    statusMessage: string;
    url?: string;
    request: {
      href: string;
    };
  }

  export function fromNode(ans: NodeResponse, body: Buffer, injector?: KrasInjectorInfo): KrasAnswer;

  export function fromHar(url: string, response: HarResponse, injector?: KrasInjectorInfo): KrasAnswer;

  export function fromJson(url: string, statusCode: number, statusText: string, headers: Headers, content: string | Buffer, injector?: KrasInjectorInfo): KrasAnswer;

  export function fromMissing(url: string): KrasAnswer;

  export function compareRequests(a: BasicKrasRequest, b: BasicKrasRequest): boolean;

  export function getClient(cwd: string, path: string): string;

  export function withFiles(server: KrasServer, config: KrasConfiguration): void;

  export function configureHandler(server: KrasServer, config?: KrasHandlerConfiguration): void;

  export interface FullKrasServer extends KrasServer {
    start(): Promise<void>;
    stop(): Promise<void>;
  }

  export function runWith(server: FullKrasServer, callback: KrasRunner): Promise<void>;

  export function isEncrypted(req: any): boolean;

  export function getPort(req: Express.Request): string;

  export function isFile(file: string): boolean;

  export function mk(directory: string): boolean;

  export function ls(directory: string): Array<string>;

  export function toAbsolute(directory: string): (file: string) => string;

  export function asJson<T = {}>(file: string): T;

  export function asScript(file: string): any;

  export function toFile<T>(file: string, obj: T): string;

  export function isInDirectory(fn: string, dir: string): boolean;

  export function watch(directory: string | Array<string>, pattern: string, callback: (type: string, file: string) => void): Watcher;

  export function open<T>(file: string): JsonStore<T>;

  export function withMiddlewares(server: KrasServer, config: KrasConfiguration): void;

  export const defaultProxyHeaders: Array<string>;

  export interface ProxyCallback {
    (err?: Error, foo?: any): void;
  }

  export interface ProxyRequestOptions {
    url: string;
    method: string;
    headers: Headers___1;
    body: string;
    agentOptions?: any;
    proxy?: any;
    injector?: KrasInjectorInfo;
    redirect?: boolean;
  }

  export function proxyRequest(req: ProxyRequestOptions, callback: ProxyCallback): any;

  export function mapReverse<T, U>(items: Array<T>, select: (item: T, index: number, rindex: number) => U): Array<U>;

  export function filterReverse<T>(items: Array<T>, check: (item: T, index: number, rindex: number) => boolean): Array<T>;

  export class MockServerCore extends WebServer {
    readonly recorder: Recorder;
    constructor(config?: WebServerConfiguration);
  }

  export interface KrasMiddleware {
    source: string;
    options: Array<any>;
    active: boolean;
    handler: KrasServerHandler;
  }

  export interface LogEntry {
    type: LogEntryType;
    time: Date;
    data: any;
  }

  export type LogEntryType = "error";

  export interface KrasHandlerConfiguration {
    handlers?: {
      [url: string]: KrasServerHandler;
    };
  }

  export interface KrasRunner {
    (s: KrasConfigurator): Promise<void> | void;
  }

  export interface Dict<T> {
    [key: string]: T;
  }

  export interface SslConfiguration {
    key: string;
    cert: string;
  }

  export interface StoredFileEntry {
    id?: number;
    active: boolean;
    file: string;
    method?: string;
    url?: string;
    error?: string;
  }

  export interface AppConfiguration {
    logLevel: LogLevel;
  }

  export interface WebServerConfigurationMap {
    [target: string]: string | boolean;
  }

  export interface WebServerConfiguration extends AppConfiguration {
    map: WebServerConfigurationMap;
    ssl: SslConfiguration;
    ws: boolean | Dict<any>;
    uploadLimit: number;
    port: number;
  }

  export interface KrasAuthSimpleAccount {
    username: string;
    password: string;
  }

  export interface KrasAuth {
    provider: "simple";
    accounts: Array<KrasAuthSimpleAccount>;
  }

  export interface KrasConfigurationInjectors {
    [name: string]: KrasInjectorConfig;
  }

  export interface KrasInjectorInfo {
    name?: string;
    host?: {
      target: string;
      address: string;
    };
    file?: {
      name: string;
      entry?: number;
    };
  }

  export type KrasResult = KrasAnswer | void;

  export type KrasResponse = Promise<KrasResult> | KrasResult;

  export interface KrasRequestHandler {
    (req: KrasRequest): KrasResponse;
  }

  export interface KrasMiddlewareDefinition {
    source: string;
    options?: Array<any>;
  }

  export interface KrasInjectorStringOption {
    type: "text";
    value: string;
  }

  export interface KrasInjectorCheckboxOption {
    type: "checkbox";
    value: boolean;
  }

  export interface KrasInjectorFileOption {
    type: "file";
    value: Array<{
      id: string;
      name: string;
      basename: string;
      active: boolean;
      error?: string;
    }>;
  }

  export interface KrasInjectorDirectoryOption {
    type: "directory";
    value: Array<string>;
  }

  export interface KrasInjectorEntryOption {
    type: "entry";
    value: Array<{
      id: string;
      name: string;
      basename: string;
      entries: Array<{
        active: boolean;
        description: string;
        error?: string;
      }>;
    }>;
  }

  export interface KrasInjectorJsonOption {
    type: "json";
    value: string;
  }

  export type KrasInjectorValueOption = KrasInjectorStringOption | KrasInjectorCheckboxOption | KrasInjectorFileOption | KrasInjectorDirectoryOption | KrasInjectorEntryOption | KrasInjectorJsonOption;

  export type KrasInjectorOption = {
    title: string;
    description: string;
  } & KrasInjectorValueOption;

  export interface RecordedRequest {
    id: string;
    start: Date;
    end: Date;
    request: KrasRequest;
    response: KrasAnswer;
  }

  export interface RecordedError {
    id: string;
    start: Date;
    end: Date;
    request: KrasRequest;
  }

  export interface WebSocketMessage {
    content: string;
    from: string;
    to: string;
    remote: boolean;
  }

  export interface RecordedMessage extends WebSocketMessage {
    id: string;
    time: Date;
  }

  export interface KrasRecorder extends Events.EventEmitter {
    readonly requests: Array<RecordedRequest>;
    readonly errors: Array<RecordedError>;
    readonly messages: Array<RecordedMessage>;
  }

  export interface KrasRequestQuery {
    [key: string]: string;
  }

  export interface BasicKrasRequest {
    url: string;
    target: string;
    query: KrasRequestQuery;
    method: string;
    headers: Http.IncomingHttpHeaders;
    content: string;
  }

  export interface KrasServerMethods {
    get(handler: KrasServerHandler): KrasServerMethods;
    put(handler: KrasServerHandler): KrasServerMethods;
    post(handler: KrasServerHandler): KrasServerMethods;
    delete(handler: KrasServerHandler): KrasServerMethods;
    any(handler: KrasServerHandler): KrasServerMethods;
    feed(handler: KrasServerConnector): KrasServerMethods;
  }

  export interface BaseKrasServer extends Events.EventEmitter {
    add(hook: KrasServerHook): void;
    remove(hook: KrasServerHook): void;
    at(...segments: Array<string>): KrasServerMethods;
    broadcast<T>(msg: T): void;
    ws: boolean;
  }

  export interface KrasServerHook {
    handle(req: Express.Request, res: Express.Response): void;
    rate(req: Express.Request): number;
  }

  export interface KrasServerHandler {
    (req: Express.Request, res: Express.Response, next?: Express.NextFunction): void;
  }

  export type KrasWebSocket = Events.EventEmitter & {
    send(msg: string): void;
    close(): void;
  };

  export interface KrasServerConnector {
    (ws: KrasWebSocket, req: Express.Request): void;
  }

  export interface KrasConfigurator {
    at(url: string): KrasServerMethods;
  }

  export interface UserCredentials {
    username: string;
    password: string;
  }

  export interface ScriptResponseBuilderData {
    statusCode?: number;
    statusText?: string;
    headers?: Headers;
    content?: string;
  }

  export interface ScriptResponseBuilder {
    (data: ScriptResponseBuilderData): KrasAnswer;
  }

  export interface ScriptFileEntry {
    active: boolean;
    file?: string;
    error?: string;
    handler?(ctx: ScriptContextData, req: KrasRequest, builder: ScriptResponseBuilder): KrasAnswer | Promise<KrasAnswer> | undefined;
  }

  export interface ScriptContextData {
    [prop: string]: any;
  }

  export class WebSocket extends Events.EventEmitter {
    /**
     * The connection is not yet open.
     */
    static readonly CONNECTING: 0;
    /**
     * The connection is open and ready to communicate.
     */
    static readonly OPEN: 1;
    /**
     * The connection is in the process of closing.
     */
    static readonly CLOSING: 2;
    /**
     * The connection is closed.
     */
    static readonly CLOSED: 3;
    binaryType: "nodebuffer" | "arraybuffer" | "fragments";
    readonly bufferedAmount: number;
    readonly extensions: string;
    readonly protocol: string;
    /**
     * The current state of the connection
     */
    readonly readyState: 0 | 1 | 2 | 3;
    readonly url: string;
    /**
     * The connection is not yet open.
     */
    readonly CONNECTING: 0;
    /**
     * The connection is open and ready to communicate.
     */
    readonly OPEN: 1;
    /**
     * The connection is in the process of closing.
     */
    readonly CLOSING: 2;
    /**
     * The connection is closed.
     */
    readonly CLOSED: 3;
    onopen(event: OpenEvent): void;
    onerror(event: ErrorEvent): void;
    onclose(event: CloseEvent): void;
    onmessage(event: MessageEvent): void;
    constructor(address: string | Url.URL, options?: ClientOptions | Http.ClientRequestArgs);
    constructor(address: string | Url.URL, protocols?: string | Array<string>, options?: ClientOptions | Http.ClientRequestArgs);
    close(code?: number, data?: string): void;
    ping(data?: any, mask?: boolean, cb?: (err: Error) => void): void;
    pong(data?: any, mask?: boolean, cb?: (err: Error) => void): void;
    send(data: any, cb?: (err?: Error) => void): void;
    send(data: any, options: {
      mask?: boolean | undefined;
      binary?: boolean | undefined;
      compress?: boolean | undefined;
      fin?: boolean | undefined;
    }, cb?: (err?: Error) => void): void;
    terminate(): void;
    addEventListener(method: "message", cb: (event: {
      data: any;
      type: string;
      target: WebSocket;
    }) => void, options?: EventListenerOptions): void;
    addEventListener(method: "close", cb: (event: {
      wasClean: boolean;
      code: number;
      reason: string;
      target: WebSocket;
    }) => void, options?: EventListenerOptions): void;
    addEventListener(method: "error", cb: (event: {
      error: any;
      message: any;
      type: string;
      target: WebSocket;
    }) => void, options?: EventListenerOptions): void;
    addEventListener(method: "open", cb: (event: {
      target: WebSocket;
    }) => void, options?: EventListenerOptions): void;
    addEventListener(method: string, listener: () => void, options?: EventListenerOptions): void;
    removeEventListener(method: "message", cb?: (event: {
      data: any;
      type: string;
      target: WebSocket;
    }) => void): void;
    removeEventListener(method: "close", cb?: (event: {
      wasClean: boolean;
      code: number;
      reason: string;
      target: WebSocket;
    }) => void): void;
    removeEventListener(method: "error", cb?: (event: {
      error: any;
      message: any;
      type: string;
      target: WebSocket;
    }) => void): void;
    removeEventListener(method: "open", cb?: (event: {
      target: WebSocket;
    }) => void): void;
    removeEventListener(method: string, listener?: () => void): void;
    on(event: "close", listener: (this: WebSocket, code: number, reason: string) => void): this;
    on(event: "error", listener: (this: WebSocket, err: Error) => void): this;
    on(event: "upgrade", listener: (this: WebSocket, request: Http.IncomingMessage) => void): this;
    on(event: "message", listener: (this: WebSocket, data: Data) => void): this;
    on(event: "open", listener: (this: WebSocket) => void): this;
    on(event: "ping" | "pong", listener: (this: WebSocket, data: Buffer) => void): this;
    on(event: "unexpected-response", listener: (this: WebSocket, request: Http.ClientRequest, response: Http.IncomingMessage) => void): this;
    on(event: string | symbol, listener: (this: WebSocket, ...args: Array<any>) => void): this;
    once(event: "close", listener: (this: WebSocket, code: number, reason: string) => void): this;
    once(event: "error", listener: (this: WebSocket, err: Error) => void): this;
    once(event: "upgrade", listener: (this: WebSocket, request: Http.IncomingMessage) => void): this;
    once(event: "message", listener: (this: WebSocket, data: Data) => void): this;
    once(event: "open", listener: (this: WebSocket) => void): this;
    once(event: "ping" | "pong", listener: (this: WebSocket, data: Buffer) => void): this;
    once(event: "unexpected-response", listener: (this: WebSocket, request: Http.ClientRequest, response: Http.IncomingMessage) => void): this;
    once(event: string | symbol, listener: (this: WebSocket, ...args: Array<any>) => void): this;
    off(event: "close", listener: (this: WebSocket, code: number, reason: string) => void): this;
    off(event: "error", listener: (this: WebSocket, err: Error) => void): this;
    off(event: "upgrade", listener: (this: WebSocket, request: Http.IncomingMessage) => void): this;
    off(event: "message", listener: (this: WebSocket, data: Data) => void): this;
    off(event: "open", listener: (this: WebSocket) => void): this;
    off(event: "ping" | "pong", listener: (this: WebSocket, data: Buffer) => void): this;
    off(event: "unexpected-response", listener: (this: WebSocket, request: Http.ClientRequest, response: Http.IncomingMessage) => void): this;
    off(event: string | symbol, listener: (this: WebSocket, ...args: Array<any>) => void): this;
    addListener(event: "close", listener: (code: number, message: string) => void): this;
    addListener(event: "error", listener: (err: Error) => void): this;
    addListener(event: "upgrade", listener: (request: Http.IncomingMessage) => void): this;
    addListener(event: "message", listener: (data: Data) => void): this;
    addListener(event: "open", listener: () => void): this;
    addListener(event: "ping" | "pong", listener: (data: Buffer) => void): this;
    addListener(event: "unexpected-response", listener: (request: Http.ClientRequest, response: Http.IncomingMessage) => void): this;
    addListener(event: string | symbol, listener: (...args: Array<any>) => void): this;
    removeListener(event: "close", listener: (code: number, message: string) => void): this;
    removeListener(event: "error", listener: (err: Error) => void): this;
    removeListener(event: "upgrade", listener: (request: Http.IncomingMessage) => void): this;
    removeListener(event: "message", listener: (data: Data) => void): this;
    removeListener(event: "open", listener: () => void): this;
    removeListener(event: "ping" | "pong", listener: (data: Buffer) => void): this;
    removeListener(event: "unexpected-response", listener: (request: Http.ClientRequest, response: Http.IncomingMessage) => void): this;
    removeListener(event: string | symbol, listener: (...args: Array<any>) => void): this;
  }

  export interface HarFileEntry {
    active: boolean;
    request: {
      method: string;
      url: string;
      target: string;
      content: string;
      headers: Headers;
      query: Headers;
    };
    response: HarResponse;
    time: number;
  }

  export interface JsonFileItem {
    active: boolean;
    request: KrasRequest;
    response: KrasAnswer | Array<KrasAnswer>;
  }

  export interface Headers___1 {
    [key: string]: any;
  }

  export class WebServer extends Events.EventEmitter implements BaseKrasServer {
    private readonly app: Express.Application & {
      ws?(target: string, connect: KrasServerConnector): void;
    };
    private readonly hooks: Array<KrasServerHook>;
    private readonly routes: Array<string>;
    private readonly port: number;
    private readonly protocol: string;
    private readonly targets: Array<string>;
    private readonly server: Server;
    private readonly wsOptions: Dict<any>;
    private sockets: WebSocketConnection;
    constructor(config?: Partial<WebServerConfiguration>);
    get ws(): boolean;
    set ws(value: boolean);
    add(hook: KrasServerHook): this;
    remove(hook: KrasServerHook): this;
    at(...segments: Array<string>): KrasServerMethods;
    start(): Promise<void>;
    stop(): Promise<void>;
    broadcast<T>(msg: T): void;
  }

  export class Recorder extends Events.EventEmitter implements KrasRecorder {
    private readonly maximum: number;
    private enabled: boolean;
    readonly requests: Array<RecordedRequest>;
    readonly errors: Array<RecordedError>;
    readonly messages: Array<RecordedMessage>;
    constructor(maximum: number);
    disable(): void;
    hit(start: Date, end: Date, request: KrasRequest, response: KrasAnswer): void;
    message(time: Date, data: WebSocketMessage): void;
    miss(start: Date, end: Date, request: KrasRequest): void;
  }

  export interface OpenEvent {
    type: string;
    target: WebSocket;
  }

  export interface ErrorEvent {
    error: any;
    message: string;
    type: string;
    target: WebSocket;
  }

  export interface CloseEvent {
    wasClean: boolean;
    code: number;
    reason: string;
    type: string;
    target: WebSocket;
  }

  export interface MessageEvent {
    data: Data;
    type: string;
    target: WebSocket;
  }

  export interface ClientOptions extends Tls.SecureContextOptions {
    protocol?: string | undefined;
    followRedirects?: boolean | undefined;
    handshakeTimeout?: number | undefined;
    maxRedirects?: number | undefined;
    perMessageDeflate?: boolean | PerMessageDeflateOptions | undefined;
    localAddress?: string | undefined;
    protocolVersion?: number | undefined;
    headers?: {
      [key: string]: string;
    } | undefined;
    origin?: string | undefined;
    agent?: Http.Agent | undefined;
    host?: string | undefined;
    family?: number | undefined;
    checkServerIdentity?(servername: string, cert: CertMeta): boolean;
    rejectUnauthorized?: boolean | undefined;
    maxPayload?: number | undefined;
  }

  export interface EventListenerOptions {
    once?: boolean | undefined;
  }

  /**
   * Data represents the message payload received over the WebSocket.
   */
  export type Data = string | Buffer | ArrayBuffer | Array<Buffer>;

  export type Server = Http.Server | Https.Server;

  export interface WebSocketConnection {
    getWss(target?: Array<string>): {
      clients: Set<{
        send(data: string): void;
      }>;
      close(): void;
    };
  }

  export interface PerMessageDeflateOptions {
    serverNoContextTakeover?: boolean | undefined;
    clientNoContextTakeover?: boolean | undefined;
    serverMaxWindowBits?: number | undefined;
    clientMaxWindowBits?: number | undefined;
    zlibDeflateOptions?: {
      flush?: number | undefined;
      finishFlush?: number | undefined;
      chunkSize?: number | undefined;
      windowBits?: number | undefined;
      level?: number | undefined;
      memLevel?: number | undefined;
      strategy?: number | undefined;
      dictionary?: Buffer | Array<Buffer> | DataView | undefined;
      info?: boolean | undefined;
    } | undefined;
    zlibInflateOptions?: Zlib.ZlibOptions | undefined;
    threshold?: number | undefined;
    concurrencyLimit?: number | undefined;
  }

  /**
   * CertMeta represents the accepted types for certificate & key data.
   */
  export type CertMeta = string | Array<string> | Buffer | Array<Buffer>;
}